diff -Naur linux-2.6.16.pristine/Makefile linux-2.6.16/Makefile
--- linux-2.6.16.pristine/Makefile	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/Makefile	2006-03-22 21:27:26.000000000 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 16
-EXTRAVERSION =
+EXTRAVERSION =-afterburn
 NAME=Sliding Snow Leopard
 
 # *DOCUMENTATION*
@@ -557,6 +557,7 @@
 
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-$(CONFIG_AFTERBURN) += afterburn/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -Naur linux-2.6.16.pristine/afterburn/Kconfig linux-2.6.16/afterburn/Kconfig
--- linux-2.6.16.pristine/afterburn/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/afterburn/Kconfig	2006-03-22 21:40:25.000000000 +0000
@@ -0,0 +1,25 @@
+
+menu "Afterburn"
+
+config AFTERBURN
+	bool "Afterburn pre-virtualization"
+	help
+	  Support for running Linux as a virtual machine in a hypervisor
+	  environment.
+
+config AFTERBURN_DEVICE_PASSTHRU
+	depends on AFTERBURN
+	bool "Permit pass through device access?"
+	default y
+
+config AFTERBURN_HOLE
+	depends on AFTERBURN
+	hex "The hole at the end of the kernel's address space (80-256 MB)"
+	range 80 256
+	default "256"
+	help
+	  Creates a hole at the end of the virtual address region for use
+	  by the hypervisor.
+
+endmenu
+
diff -Naur linux-2.6.16.pristine/afterburn/Makefile linux-2.6.16/afterburn/Makefile
--- linux-2.6.16.pristine/afterburn/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/afterburn/Makefile	2006-03-22 21:27:26.000000000 +0000
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_AFTERBURN) += afterburn.o
+
diff -Naur linux-2.6.16.pristine/afterburn/afterburn.c linux-2.6.16/afterburn/afterburn.c
--- linux-2.6.16.pristine/afterburn/afterburn.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/afterburn/afterburn.c	2006-03-29 14:18:21.000000000 +0000
@@ -0,0 +1,36 @@
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <asm/current.h>
+#include <asm/pgtable.h>
+
+// Exports to the afterburn wedge.
+
+__attribute__((section(".data"))) int (*afterburn_rewrite_module_hook)( unsigned long ) = NULL;
+
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+__attribute__((section(".data"))) unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+__attribute__((section(".data"))) unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+#endif
+
+#define IMPORT_PHYS_TO_DMA_HOOK		12
+#define IMPORT_DMA_TO_PHYS_HOOK		13
+#define IMPORT_REWRITE_MODULE_HOOK	15
+
+// These macros install the info into an unallocated ELF section.
+#define AFTERBURN_IMPORT( id, ptr ) \
+    EXPORT_SYMBOL( ptr ); \
+    asm ( ".pushsection .afterburn.imports;" \
+	    ".long " MKSTR(id) ";" \
+	    ".long " MKSTR(ptr) ";" \
+	    ".popsection;" )
+
+#define MKSTR(sym)	MKSTR2(sym)
+#define MKSTR2(sym)	#sym
+
+AFTERBURN_IMPORT( IMPORT_REWRITE_MODULE_HOOK, afterburn_rewrite_module_hook );
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+AFTERBURN_IMPORT( IMPORT_PHYS_TO_DMA_HOOK, afterburn_phys_to_dma_hook );
+AFTERBURN_IMPORT( IMPORT_DMA_TO_PHYS_HOOK, afterburn_dma_to_phys_hook );
+#endif
+
diff -Naur linux-2.6.16.pristine/afterburn/annotate.h linux-2.6.16/afterburn/annotate.h
--- linux-2.6.16.pristine/afterburn/annotate.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/afterburn/annotate.h	2006-03-29 14:18:34.000000000 +0000
@@ -0,0 +1,190 @@
+#ifndef __AFTERBURN__ANNOTATE_H__
+#define __AFTERBURN__ANNOTATE_H__
+
+#include <asm/bitops.h>
+
+#define pgd_read_annotate( pgd ) ({ \
+    unsigned long temp; \
+    __asm__ ( \
+	    "7777:" \
+	    "mov %1, %0\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "7778:" \
+	    ".pushsection .afterburn.pgd_read\n" \
+	    ".align 4\n" \
+	    ".long 7777b\n" \
+	    ".long 7778b\n" \
+	    ".popsection\n" \
+	    : "=r"(temp) : "m"(pgd) ); \
+    temp; })
+
+
+#define pte_read_annotate( pte ) ({ \
+    unsigned long temp; \
+    __asm__ ( \
+	    "7777:" \
+	    "mov %1, %0\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "7778:" \
+	    ".pushsection .afterburn.pte_read\n" \
+	    ".align 4\n" \
+	    ".long 7777b\n" \
+	    ".long 7778b\n" \
+	    ".popsection\n" \
+	    : "=r"(temp) : "m"(pte) ); \
+    temp; })
+
+static inline void 
+pte_set_annotate(pte_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val), "m"(*addr) );
+}
+
+static inline void 
+pgd_set_annotate(pgd_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pgd_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val) );
+}
+
+static inline int
+pte_test_and_clear_bit_annotate( int bit, volatile pte_t *ptep )
+{
+    int oldbit;
+
+    __asm__ (
+	    "7777:"
+	    LOCK_PREFIX
+	    "btrl %2, %1\n"
+	    "sbbl %0, %0\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_test_clear\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=a"(oldbit), "=m"(*(volatile long *)ptep)
+	    : "0"(bit) );
+    return oldbit;
+}
+
+static inline pte_t
+pte_read_clear_annotate( pte_t *pteptr )
+{
+    pte_t x = {0};
+
+    __asm__ (
+	    "7777:"
+	    "xchgl %0, %1\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_read\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(x) 
+	    : "m"(*(volatile unsigned long *)pteptr), "0"(x)
+	    : "memory" );
+
+    return x;
+}
+
+#endif /* __AFTERBURN__ANNOTATE_H__ */
diff -Naur linux-2.6.16.pristine/arch/i386/Kconfig linux-2.6.16/arch/i386/Kconfig
--- linux-2.6.16.pristine/arch/i386/Kconfig	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/arch/i386/Kconfig	2006-03-22 21:27:26.000000000 +0000
@@ -751,6 +751,7 @@
 
 endmenu
 
+source "afterburn/Kconfig"
 
 menu "Power management options (ACPI, APM)"
 	depends on !X86_VOYAGER
diff -Naur linux-2.6.16.pristine/arch/i386/kernel/pci-dma.c linux-2.6.16/arch/i386/kernel/pci-dma.c
--- linux-2.6.16.pristine/arch/i386/kernel/pci-dma.c	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/arch/i386/kernel/pci-dma.c	2006-03-29 14:19:14.000000000 +0000
@@ -14,6 +14,10 @@
 #include <linux/module.h>
 #include <asm/io.h>
 
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+#endif
+
 struct dma_coherent_mem {
 	void		*virt_base;
 	u32		device_base;
@@ -50,8 +54,13 @@
 	ret = (void *)__get_free_pages(gfp, order);
 
 	if (ret != NULL) {
-		memset(ret, 0, size);
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+		if (afterburn_phys_to_dma_hook)
+			*dma_handle = afterburn_phys_to_dma_hook(virt_to_phys(ret), size);
+		else
+#endif
 		*dma_handle = virt_to_phys(ret);
+		memset(ret, 0, size);
 	}
 	return ret;
 }
diff -Naur linux-2.6.16.pristine/arch/i386/mm/fault.c linux-2.6.16/arch/i386/mm/fault.c
--- linux-2.6.16.pristine/arch/i386/mm/fault.c	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/arch/i386/mm/fault.c	2006-03-22 21:27:26.000000000 +0000
@@ -456,7 +456,7 @@
 	printk(KERN_ALERT " printing eip:\n");
 	printk("%08lx\n", regs->eip);
 	page = read_cr3();
-	page = ((unsigned long *) __va(page))[address >> 22];
+	page = pgd_val( ((pgd_t *) __va(page))[address >> 22] );
 	printk(KERN_ALERT "*pde = %08lx\n", page);
 	/*
 	 * We must not directly access the pte in the highpte
diff -Naur linux-2.6.16.pristine/arch/i386/mm/init.c linux-2.6.16/arch/i386/mm/init.c
--- linux-2.6.16.pristine/arch/i386/mm/init.c	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/arch/i386/mm/init.c	2006-03-22 21:27:26.000000000 +0000
@@ -368,7 +368,7 @@
 	 * created - mappings will be set by set_fixmap():
 	 */
 	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
-	page_table_range_init(vaddr, 0, pgd_base);
+	page_table_range_init(vaddr, vaddr + PMD_SIZE, pgd_base);
 
 	permanent_kmaps_init(pgd_base);
 
@@ -380,7 +380,7 @@
 	 * All user-space mappings are explicitly cleared after
 	 * SMP startup.
 	 */
-	set_pgd(&pgd_base[0], pgd_base[USER_PTRS_PER_PGD]);
+	set_pgd(&pgd_base[0], pgd_base[USER_PGD_PTRS]);
 #endif
 }
 
@@ -414,7 +414,7 @@
 	 * Note that "pgd_clear()" doesn't do it for
 	 * us, because pgd_clear() is a no-op on i386.
 	 */
-	for (i = 0; i < USER_PTRS_PER_PGD; i++)
+	for (i = 0; i < USER_PGD_PTRS; i++)
 #ifdef CONFIG_X86_PAE
 		set_pgd(swapper_pg_dir+i, __pgd(1 + __pa(empty_zero_page)));
 #else
diff -Naur linux-2.6.16.pristine/include/asm-i386/dma-mapping.h linux-2.6.16/include/asm-i386/dma-mapping.h
--- linux-2.6.16.pristine/include/asm-i386/dma-mapping.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/dma-mapping.h	2006-03-27 13:42:24.000000000 +0000
@@ -8,6 +8,10 @@
 #include <asm/scatterlist.h>
 #include <asm/bug.h>
 
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+#endif
+
 #define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 #define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 
@@ -25,6 +29,10 @@
 		BUG();
 	WARN_ON(size == 0);
 	flush_write_buffers();
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(virt_to_phys(ptr), size);
+#endif
 	return virt_to_phys(ptr);
 }
 
@@ -49,6 +57,11 @@
 	for (i = 0; i < nents; i++ ) {
 		BUG_ON(!sg[i].page);
 
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+		if (afterburn_phys_to_dma_hook)
+			sg[i].dma_address = afterburn_phys_to_dma_hook(page_to_phys(sg[i].page), sg[i].length) + sg[i].offset;
+		else
+#endif
 		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
 	}
 
@@ -61,6 +74,10 @@
 	     size_t size, enum dma_data_direction direction)
 {
 	BUG_ON(direction == DMA_NONE);
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(page_to_phys(page), PAGE_SIZE) + offset;
+#endif
 	return page_to_phys(page) + offset;
 }
 
diff -Naur linux-2.6.16.pristine/include/asm-i386/fixmap.h linux-2.6.16/include/asm-i386/fixmap.h
--- linux-2.6.16.pristine/include/asm-i386/fixmap.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/fixmap.h	2006-03-22 21:44:41.000000000 +0000
@@ -20,7 +20,11 @@
  * Leave one empty page between vmalloc'ed areas and
  * the start of the fixmap.
  */
-#define __FIXADDR_TOP	0xfffff000
+#if defined(CONFIG_AFTERBURN)
+#define __FIXADDR_TOP (0xfffff000-(CONFIG_AFTERBURN_HOLE << 20))
+#else
+#define __FIXADDR_TOP 0xfffff000
+#endif
 
 #ifndef __ASSEMBLY__
 #include <linux/kernel.h>
diff -Naur linux-2.6.16.pristine/include/asm-i386/io.h linux-2.6.16/include/asm-i386/io.h
--- linux-2.6.16.pristine/include/asm-i386/io.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/io.h	2006-03-27 13:43:09.000000000 +0000
@@ -45,6 +45,12 @@
 
 #ifdef __KERNEL__
 
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+extern unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+#include <linux/mm.h>
+#endif
+
 #include <asm-generic/iomap.h>
 
 #include <linux/vmalloc.h>
@@ -139,6 +145,36 @@
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
  */
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+static inline unsigned long virt_to_bus( void * virt )
+{
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(virt_to_phys(virt), PAGE_SIZE);
+	else
+		return virt_to_phys(virt);
+}
+
+static inline void * bus_to_virt( unsigned long bus )
+{
+	if (afterburn_dma_to_phys_hook)
+		return phys_to_virt(afterburn_dma_to_phys_hook(bus));
+	else
+		return phys_to_virt(bus);
+}
+
+static inline unsigned long page_to_bus( struct page *page )
+{
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(page_to_phys(page), PAGE_SIZE);
+	else
+		return page_to_phys(page);
+}
+
+#define isa_virt_to_bus virt_to_bus
+#define isa_page_to_bus page_to_bus
+#define isa_bus_to_virt bus_to_virt
+
+#else
 #define isa_virt_to_bus virt_to_phys
 #define isa_page_to_bus page_to_phys
 #define isa_bus_to_virt phys_to_virt
@@ -151,6 +187,7 @@
  */
 #define virt_to_bus virt_to_phys
 #define bus_to_virt phys_to_virt
+#endif
 
 /*
  * readX/writeX() are used to access memory mapped devices. On some
diff -Naur linux-2.6.16.pristine/include/asm-i386/page.h linux-2.6.16/include/asm-i386/page.h
--- linux-2.6.16.pristine/include/asm-i386/page.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/page.h	2006-03-29 14:31:05.000000000 +0000
@@ -58,7 +58,8 @@
 typedef struct { unsigned long pgd; } pgd_t;
 typedef struct { unsigned long pgprot; } pgprot_t;
 #define boot_pte_t pte_t /* or would you rather have a typedef */
-#define pte_val(x)	((x).pte_low)
+
+
 #define HPAGE_SHIFT	22
 #endif
 #define PTE_MASK	PAGE_MASK
@@ -70,7 +71,13 @@
 #define HAVE_ARCH_HUGETLB_UNMAPPED_AREA
 #endif
 
+#if !defined(CONFIG_AFTERBURN)                                      
 #define pgd_val(x)	((x).pgd)
+#else
+#include "../../afterburn/annotate.h"
+#define pgd_val(x) (pgd_read_annotate( (x).pgd ))
+#endif
+#define pte_val(x)	((x).pte_low)
 #define pgprot_val(x)	((x).pgprot)
 
 #define __pte(x) ((pte_t) { (x) } )
@@ -121,7 +128,11 @@
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
+#if defined(CONFIG_AFTERBURN)
+#define MAXMEM			(-(CONFIG_AFTERBURN_HOLE << 20)-__PAGE_OFFSET-__VMALLOC_RESERVE)
+#else
 #define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
+#endif
 #define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
 #define pfn_to_kaddr(pfn)      __va((pfn) << PAGE_SHIFT)
diff -Naur linux-2.6.16.pristine/include/asm-i386/pci.h linux-2.6.16/include/asm-i386/pci.h
--- linux-2.6.16.pristine/include/asm-i386/pci.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/pci.h	2006-03-27 13:44:05.000000000 +0000
@@ -63,6 +63,12 @@
 static inline dma64_addr_t
 pci_dac_page_to_dma(struct pci_dev *pdev, struct page *page, unsigned long offset, int direction)
 {
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+    extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+    if (afterburn_phys_to_dma_hook)
+	return ((dma64_addr_t)afterburn_phys_to_dma_hook(page_to_phys(page), PAGE_SIZE) + (dma64_addr_t)offset);
+    else
+#endif
 	return ((dma64_addr_t) page_to_phys(page) +
 		(dma64_addr_t) offset);
 }
@@ -70,6 +76,12 @@
 static inline struct page *
 pci_dac_dma_to_page(struct pci_dev *pdev, dma64_addr_t dma_addr)
 {
+#if defined(CONFIG_AFTERBURN_DEVICE_PASSTHRU)
+    extern unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+    if (afterburn_dma_to_phys_hook)
+	return pfn_to_page(afterburn_dma_to_phys_hook(dma_addr) >> PAGE_SHIFT);
+    else
+#endif
 	return pfn_to_page(dma_addr >> PAGE_SHIFT);
 }
 
diff -Naur linux-2.6.16.pristine/include/asm-i386/pgtable-2level.h linux-2.6.16/include/asm-i386/pgtable-2level.h
--- linux-2.6.16.pristine/include/asm-i386/pgtable-2level.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/pgtable-2level.h	2006-03-24 13:52:58.000000000 +0000
@@ -13,16 +13,29 @@
  * within a page table are directly modified.  Thus, the following
  * hook is made available.
  */
+#if defined(CONFIG_AFTERBURN)
+#include "../../afterburn/annotate.h"
+#define set_pte(pteptr, pteval) pte_set_annotate( (pte_t *)(pteptr), (pteval).pte_low )
+#define set_pmd(pmdptr, pmdval) pgd_set_annotate( (pgd_t *)(pmdptr), (pmdval).pud.pgd.pgd )
+#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
+#define set_pte_atomic(pteptr, pteval) set_pte(pteptr,pteval)
+#define ptep_get_and_clear(mm,addr,xp)	pte_read_clear_annotate(xp)
+#define pte_pfn(x)		((unsigned long)(pte_read_annotate((x).pte_low)) >> PAGE_SHIFT)
+#define pte_same(a, b)		(pte_read_annotate((a).pte_low) == pte_read_annotate((b).pte_low))
+
+#else
+
 #define set_pte(pteptr, pteval) (*(pteptr) = pteval)
 #define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
 #define set_pte_atomic(pteptr, pteval) set_pte(pteptr,pteval)
 #define set_pmd(pmdptr, pmdval) (*(pmdptr) = (pmdval))
-
 #define ptep_get_and_clear(mm,addr,xp)	__pte(xchg(&(xp)->pte_low, 0))
+#define pte_pfn(x)		((unsigned long)(((pte_val(x)) >> PAGE_SHIFT)))
 #define pte_same(a, b)		((a).pte_low == (b).pte_low)
+#endif
+
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
 #define pte_none(x)		(!(x).pte_low)
-#define pte_pfn(x)		((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
 #define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 
diff -Naur linux-2.6.16.pristine/include/asm-i386/pgtable.h linux-2.6.16/include/asm-i386/pgtable.h
--- linux-2.6.16.pristine/include/asm-i386/pgtable.h	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/include/asm-i386/pgtable.h	2006-03-29 14:31:41.000000000 +0000
@@ -212,7 +212,6 @@
 #define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
 #define	pmd_bad(x)	((pmd_val(x) & (~PAGE_MASK & ~_PAGE_USER)) != _KERNPG_TABLE)
 
-
 #define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
 
 /*
@@ -250,10 +249,17 @@
 # include <asm/pgtable-2level.h>
 #endif
 
+#if defined(CONFIG_AFTERBURN)
+#include "../../afterburn/annotate.h"
+#endif
+
 static inline int ptep_test_and_clear_dirty(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)
 {
 	if (!pte_dirty(*ptep))
 		return 0;
+#if defined(CONFIG_AFTERBURN)
+	return pte_test_and_clear_bit_annotate( _PAGE_BIT_DIRTY, ptep );
+#endif
 	return test_and_clear_bit(_PAGE_BIT_DIRTY, &ptep->pte_low);
 }
 
@@ -261,11 +267,17 @@
 {
 	if (!pte_young(*ptep))
 		return 0;
+#if defined(CONFIG_AFTERBURN)
+	return pte_test_and_clear_bit_annotate( _PAGE_BIT_ACCESSED, ptep );
+#endif
 	return test_and_clear_bit(_PAGE_BIT_ACCESSED, &ptep->pte_low);
 }
 
 static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm, unsigned long addr, pte_t *ptep, int full)
 {
+#if defined(CONFIG_AFTERBURN)
+	return ptep_get_and_clear(mm, addr, ptep);
+#endif
 	pte_t pte;
 	if (full) {
 		pte = *ptep;
@@ -278,6 +290,10 @@
 
 static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
+#if defined(CONFIG_AFTERBURN)
+	pte_test_and_clear_bit_annotate( _PAGE_BIT_RW, ptep );
+	return;
+#endif
 	clear_bit(_PAGE_BIT_RW, &ptep->pte_low);
 }
 
@@ -427,7 +443,7 @@
 #define ptep_set_access_flags(__vma, __address, __ptep, __entry, __dirty) \
 	do {								  \
 		if (__dirty) {						  \
-			(__ptep)->pte_low = (__entry).pte_low;	  	  \
+			set_pte(__ptep, __entry);                         \
 			flush_tlb_page(__vma, __address);		  \
 		}							  \
 	} while (0)
diff -Naur linux-2.6.16.pristine/kernel/module.c linux-2.6.16/kernel/module.c
--- linux-2.6.16.pristine/kernel/module.c	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/kernel/module.c	2006-03-22 22:10:47.000000000 +0000
@@ -1742,6 +1742,17 @@
 		DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);
 	}
 	/* Module has been moved. */
+#if defined(CONFIG_AFTERBURN)
+	{
+	    extern int (*afterburn_rewrite_module_hook)(Elf_Ehdr *);
+	    if( afterburn_rewrite_module_hook && 
+		    !afterburn_rewrite_module_hook(hdr) ) {
+	       	err = -ENOEXEC;
+    		goto cleanup;
+	    }
+	}
+#endif
+
 	mod = (void *)sechdrs[modindex].sh_addr;
 
 	/* Now we've moved module, initialize linked lists, etc. */
diff -Naur linux-2.6.16.pristine/scripts/Makefile.build linux-2.6.16/scripts/Makefile.build
--- linux-2.6.16.pristine/scripts/Makefile.build	2006-03-20 05:53:29.000000000 +0000
+++ linux-2.6.16/scripts/Makefile.build	2006-03-22 21:27:27.000000000 +0000
@@ -146,7 +146,13 @@
 quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
 
 ifndef CONFIG_MODVERSIONS
+ifndef CONFIG_AFTERBURN
 cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
+else
+cmd_cc_o_c  = $(CC) $(c_flags) -c -S -o $(@D)/.preburn_$(@F:.o=.s) $<
+cmd_cc_o_c += && afterburner $(@D)/.preburn_$(@F:.o=.s) > $(@D)/.afterburnt_$(@F:.o=.s)
+cmd_cc_o_c += && $(CC) $(c_flags) -c -o $@ $(@D)/.afterburnt_$(@F:.o=.s)
+endif
 
 else
 # When module versioning is enabled the following steps are executed:
@@ -223,7 +229,13 @@
 	$(call if_changed_dep,as_s_S)
 
 quiet_cmd_as_o_S = AS $(quiet_modtag)  $@
+ifndef CONFIG_AFTERBURN
 cmd_as_o_S       = $(CC) $(a_flags) -c -o $@ $<
+else
+cmd_as_o_S        = $(CC) $(a_flags) -c -E -o $(@D)/.preburn_$(@F:.o=.s) $<
+cmd_as_o_S       += && afterburner $(@D)/.preburn_$(@F:.o=.s) > $(@D)/.afterburnt_$(@F:.o=.s)
+cmd_as_o_S       += && $(CC) $(a_flags) -c -o $@ $(@D)/.afterburnt_$(@F:.o=.s)
+endif
 
 %.o: %.S FORCE
 	$(call if_changed_dep,as_o_S)
