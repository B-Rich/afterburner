diff -Naur linux-2.6.8.1.pristine/Makefile linux-2.6.8.1/Makefile
--- linux-2.6.8.1.pristine/Makefile	2004-08-14 10:55:35.000000000 +0000
+++ linux-2.6.8.1/Makefile	2006-08-17 16:12:43.000000000 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 8
-EXTRAVERSION = .1
+EXTRAVERSION = .1-afterburn
 NAME=Zonked Quokka
 
 # *DOCUMENTATION*
@@ -141,7 +141,9 @@
 
 export srctree objtree VPATH TOPDIR
 
-KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+LOCALVERSION = $(subst ",,$(CONFIG_LOCALVERSION))
+
+KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(LOCALVERSION)
 
 # SUBARCH tells the usermode build what the underlying arch is.  That is set
 # first, and if a usermode build is happening, the "ARCH=um" on the command
@@ -479,6 +481,7 @@
 
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
+core-$(CONFIG_AFTERBURN) += afterburn/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -Naur linux-2.6.8.1.pristine/afterburn/Kconfig linux-2.6.8.1/afterburn/Kconfig
--- linux-2.6.8.1.pristine/afterburn/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8.1/afterburn/Kconfig	2006-09-07 09:21:17.000000000 +0000
@@ -0,0 +1,113 @@
+
+menu "Afterburn"
+
+config AFTERBURN
+	bool "Afterburn pre-virtualization"
+	help
+	  Support for running Linux as a virtual machine in a hypervisor
+	  environment.
+
+#config AFTERBURN_STATIC
+#	depends on AFTERBURN
+#	bool "Staticly link against wedge"
+#	default y
+#	help
+#          Instruction afterburning is normally staticaly linked at build time
+#          and you limit yourself to the particular wedge. Use this option to instead
+#          generate dynamic patchup symbols instead.
+
+config AFTERBURN_L4KA
+	depends on AFTERBURN
+	bool "Support the L4Ka::Pistachio environment?"
+	default y
+	select AFTERBURN_RELINK
+	select AFTERBURN_HOOK_UACCESS
+	select AFTERBURN_ANNOTATIONS
+	select AFTERBURN_THREAD_HOOKS
+	select AFTERBURN_MODULE_HOOKS
+
+config AFTERBURN_XEN
+	depends on AFTERBURN
+	bool "Support the Xen environment?"
+	default y
+	select AFTERBURN_RELINK
+	select AFTERBURN_ANNOTATIONS
+	select AFTERBURN_XEN_HOOKS
+	select AFTERBURN_MODULE_HOOKS
+
+config AFTERBURN_DEVICE_PASSTHRU
+	depends on AFTERBURN
+	bool "Permit pass through device access?"
+	default y
+	select AFTERBURN_HOOK_DMA
+
+config AFTERBURN_KERNEL_PROFILING
+	depends on AFTERBURN
+	bool "Profile the kernel? (Requires frame pointers)"
+	select DEBUG_KERNEL
+	select FRAME_POINTER
+
+menu "Advanced"
+depends on AFTERBURN
+
+config AFTERBURN_RELINK
+	depends on AFTERBURN
+	bool "Relink the Linux kernel at a new address?"
+	default y
+
+config AFTERBURN_LINK_BASE
+	depends on AFTERBURN && AFTERBURN_RELINK
+	hex "The kernel link address"
+	default "0x80000000"
+	help
+	  This address is the first byte location of where the kernel's
+	  available virtual address space starts.
+
+config AFTERBURN_VADDR_END
+	depends on AFTERBURN && AFTERBURN_RELINK
+	hex "The end of the kernel's virtual address space"
+	default "0xbc000000"
+	help
+	  This address is the first byte location of where *unavailable*
+	  memory starts.  It is thus the end of the kernel's available
+	  virtual address space.  If you use a dynamic wedge, consider
+	  leaving enough room for the wedge to link itself at the
+	  end of the kernel's available virtual address space.
+
+config AFTERBURN_USER_VADDR_END
+	depends on AFTERBURN && AFTERBURN_RELINK
+	hex "The end of a user application's virtual address space"
+	default "0x80000000"
+	help
+	  This address marks the end of the user address space managed
+	  by Linux.  All addresses starting here and beyond are managed 
+	  by the hypervisor.
+
+config AFTERBURN_HOOK_UACCESS
+	depends on AFTERBURN
+	bool "Permit the virtual machine to hook user data access?"
+
+config AFTERBURN_HOOK_DMA
+	depends on AFTERBURN
+	bool "Permit the virtual machine to hook DMA translation?"
+
+config AFTERBURN_XEN_HOOKS
+	depends on AFTERBURN
+	bool "Extra afterburn hooks required for Xen"
+
+config AFTERBURN_ANNOTATIONS
+	depends on AFTERBURN
+	bool "Generate Afterburn annotations and NOPs for optimizations"
+
+config AFTERBURN_THREAD_HOOKS
+	depends on AFTERBURN
+	bool "Permit the virtual machine to hook high-level thread operations?"
+
+config AFTERBURN_MODULE_HOOKS
+	depends on AFTERBURN
+	bool "Support dynamic kernel module loading?"
+	default y
+
+endmenu
+endmenu
+
diff -Naur linux-2.6.8.1.pristine/afterburn/Makefile linux-2.6.8.1/afterburn/Makefile
--- linux-2.6.8.1.pristine/afterburn/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8.1/afterburn/Makefile	2006-08-18 16:13:54.000000000 +0000
@@ -0,0 +1,4 @@
+
+obj-$(CONFIG_AFTERBURN) += afterburn.o
+obj-$(CONFIG_AFTERBURN_DRIVERS) += drivers/
+
diff -Naur linux-2.6.8.1.pristine/afterburn/afterburn.c linux-2.6.8.1/afterburn/afterburn.c
--- linux-2.6.8.1.pristine/afterburn/afterburn.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8.1/afterburn/afterburn.c	2006-08-16 15:51:17.000000000 +0000
@@ -0,0 +1,140 @@
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <asm/current.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+
+// Exports to the afterburn wedge.
+
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+void * afterburn_thread_get_handle( void )
+{
+    return current->afterburn_handle;
+}
+
+void afterburn_thread_assign_handle( void * handle )
+{
+    current->afterburn_handle = handle;
+}
+
+
+// Imports from the afterburn wedge.  If these hooks are in the bss,
+// Linux will zero them after the wedge has hooked them.
+
+void afterburn_exit_thread( void *handle )
+{
+    // Dummy
+}
+
+int afterburn_signal_thread( void *handle )
+{
+    // Dummy
+    return 0;
+}
+
+void (*afterburn_exit_hook)( void *handle ) = afterburn_exit_thread;
+int (*afterburn_signal_hook)( void *handle ) = afterburn_signal_thread;
+#endif	/* CONFIG_AFTERBURN_THREAD_HOOKS */
+
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+__attribute__((section(".data"))) int (*afterburn_rewrite_module_hook)( unsigned long ) = NULL;
+#endif
+
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+__attribute__((section(".data"))) void (*afterburn_sync_esp0)(void) = NULL;
+#endif
+
+__attribute__((section("__ex_table"))) struct exception_table_entry 
+  afterburn_uaccess_fault_handler = {
+      (long)&afterburn_uaccess_fault_handler, 
+      (long)&afterburn_uaccess_fault_handler
+  };
+
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+__attribute__((section(".data"))) unsigned long (*afterburn_get_user_hook)(void *to, const void *from, unsigned long n)  = NULL;
+__attribute__((section(".data"))) unsigned long (*afterburn_put_user_hook)(void *to, const void *from, unsigned long n) = NULL;
+__attribute__((section(".data"))) unsigned long (*afterburn_copy_from_user_hook)(void *to, const void *from, unsigned long n)  = NULL;
+__attribute__((section(".data"))) unsigned long (*afterburn_copy_to_user_hook)(void *to, const void *from, unsigned long n) = NULL;
+__attribute__((section(".data"))) unsigned long (*afterburn_clear_user_hook)(void *to, unsigned long n) = NULL;
+__attribute__((section(".data"))) unsigned long (*afterburn_strnlen_user_hook)(const char *s, unsigned long n) = NULL;
+__attribute__((section(".data"))) unsigned long (*afterburn_strncpy_from_user_hook)(char *dst, const char *src, unsigned long n, unsigned long *success) = NULL;
+#endif
+
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+__attribute__((section(".data"))) unsigned long (*afterburn_dma_coherent_check)(unsigned long phys, unsigned long size);
+__attribute__((section(".data"))) unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+__attribute__((section(".data"))) unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+#endif
+
+#define EXPORT_THREAD_GET_HANDLE	0
+#define EXPORT_THREAD_SET_HANDLE	1
+#define EXPORT_UACCESS_FAULT_DATA	2
+#define EXPORT_BURN_PROF_COUNTERS_START	3
+#define EXPORT_BURN_PROF_COUNTERS_END	4
+
+#define IMPORT_EXIT_HOOK		0
+#define IMPORT_SET_PTE_HOOK		1
+#define IMPORT_GET_USER_HOOK		2
+#define IMPORT_PUT_USER_HOOK		3
+#define IMPORT_COPY_FROM_USER_HOOK	4
+#define IMPORT_COPY_TO_USER_HOOK	5
+#define IMPORT_CLEAR_USER_HOOK		6
+#define IMPORT_STRNLEN_USER_HOOK	7
+#define IMPORT_STRNCPY_FROM_USER_HOOK	8
+#define IMPORT_READ_PTE_HOOK		9
+#define IMPORT_PTE_TEST_AND_CLEAR_HOOK	10
+#define IMPORT_PTE_GET_AND_CLEAR_HOOK	11
+#define IMPORT_PHYS_TO_DMA_HOOK		12
+#define IMPORT_DMA_TO_PHYS_HOOK		13
+#define IMPORT_FREE_PGD_HOOK		14
+#define IMPORT_REWRITE_MODULE_HOOK	15
+#define IMPORT_SIGNAL_HOOK		16
+#define IMPORT_ESP0_SYNC		17
+#define IMPORT_DMA_COHERENT_CHECK       18
+
+// These macros install the info into an unallocated ELF section.
+#define AFTERBURN_EXPORT( id, func ) \
+    asm ( ".pushsection .afterburn.exports;" \
+	    ".long " MKSTR(id) ";" \
+	    ".long " MKSTR(func) ";" \
+	    ".popsection;" )
+#define AFTERBURN_IMPORT( id, ptr ) \
+    EXPORT_SYMBOL( ptr ); \
+    asm ( ".pushsection .afterburn.imports;" \
+	    ".long " MKSTR(id) ";" \
+	    ".long " MKSTR(ptr) ";" \
+	    ".popsection;" )
+
+#define MKSTR(sym)	MKSTR2(sym)
+#define MKSTR2(sym)	#sym
+
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+AFTERBURN_EXPORT( EXPORT_THREAD_GET_HANDLE, afterburn_thread_get_handle );
+AFTERBURN_EXPORT( EXPORT_THREAD_SET_HANDLE, afterburn_thread_assign_handle );
+AFTERBURN_IMPORT( IMPORT_EXIT_HOOK, afterburn_exit_hook );
+AFTERBURN_IMPORT( IMPORT_SIGNAL_HOOK, afterburn_signal_hook );
+#endif
+AFTERBURN_EXPORT( EXPORT_UACCESS_FAULT_DATA, afterburn_uaccess_fault_handler );
+AFTERBURN_EXPORT( EXPORT_BURN_PROF_COUNTERS_START, __burn_prof_counters_start );
+AFTERBURN_EXPORT( EXPORT_BURN_PROF_COUNTERS_END, __burn_prof_counters_end );
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+AFTERBURN_IMPORT( IMPORT_GET_USER_HOOK, afterburn_get_user_hook );
+AFTERBURN_IMPORT( IMPORT_COPY_FROM_USER_HOOK, afterburn_copy_from_user_hook );
+AFTERBURN_IMPORT( IMPORT_PUT_USER_HOOK, afterburn_put_user_hook );
+AFTERBURN_IMPORT( IMPORT_COPY_TO_USER_HOOK, afterburn_copy_to_user_hook );
+AFTERBURN_IMPORT( IMPORT_CLEAR_USER_HOOK, afterburn_clear_user_hook );
+AFTERBURN_IMPORT( IMPORT_STRNLEN_USER_HOOK, afterburn_strnlen_user_hook );
+AFTERBURN_IMPORT( IMPORT_STRNCPY_FROM_USER_HOOK, afterburn_strncpy_from_user_hook );
+#endif
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+AFTERBURN_IMPORT( IMPORT_DMA_COHERENT_CHECK, afterburn_dma_coherent_check );
+AFTERBURN_IMPORT( IMPORT_PHYS_TO_DMA_HOOK, afterburn_phys_to_dma_hook );
+AFTERBURN_IMPORT( IMPORT_DMA_TO_PHYS_HOOK, afterburn_dma_to_phys_hook );
+#endif
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+AFTERBURN_IMPORT( IMPORT_REWRITE_MODULE_HOOK, afterburn_rewrite_module_hook );
+#endif
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+AFTERBURN_IMPORT( IMPORT_ESP0_SYNC, afterburn_sync_esp0 );
+#endif
diff -Naur linux-2.6.8.1.pristine/afterburn/annotate.h linux-2.6.8.1/afterburn/annotate.h
--- linux-2.6.8.1.pristine/afterburn/annotate.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8.1/afterburn/annotate.h	2006-08-16 16:01:27.000000000 +0000
@@ -0,0 +1,442 @@
+#ifndef __AFTERBURN__ANNOTATE_H__
+#define __AFTERBURN__ANNOTATE_H__
+
+#include <asm/bitops.h>
+
+static inline void 
+dp83820_write_annotate(unsigned int b, volatile void *addr)
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.dp83820\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(b), "m"(*(unsigned long *)addr) : "memory" );
+}
+
+static inline unsigned int 
+dp83820_read_annotate(const volatile void *addr)
+{
+    unsigned int temp;
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.dp83820\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(temp) : "m"(*(unsigned long *)addr) );
+    return temp;
+}
+
+#define pgd_read_annotate( pgd ) ({ \
+    unsigned long temp; \
+    __asm__ ( \
+	    "7777:" \
+	    "mov %1, %0\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "7778:" \
+	    ".pushsection .afterburn.pgd_read\n" \
+	    ".align 4\n" \
+	    ".long 7777b\n" \
+	    ".long 7778b\n" \
+	    ".popsection\n" \
+	    : "=r"(temp) : "m"(pgd) ); \
+    temp; })
+
+
+#define pte_read_annotate( pte ) ({ \
+    unsigned long temp; \
+    __asm__ ( \
+	    "7777:" \
+	    "mov %1, %0\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "7778:" \
+	    ".pushsection .afterburn.pte_read\n" \
+	    ".align 4\n" \
+	    ".long 7777b\n" \
+	    ".long 7778b\n" \
+	    ".popsection\n" \
+	    : "=r"(temp) : "m"(pte) ); \
+    temp; })
+
+static inline void 
+pte_set_annotate(pte_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val), "m"(*addr) );
+}
+
+static inline void 
+pgd_set_annotate(pgd_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pgd_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val) );
+}
+
+static inline void 
+pmd_set_annotate(pmd_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pmd_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val) );
+}
+
+static inline int pte_test_and_clear_bit_annotate( int bit, volatile pte_t *ptep )
+{
+    int oldbit;
+
+    __asm__ (
+	    "7777:"
+	    LOCK_PREFIX
+	    "btrl %2, %1\n"
+	    "sbbl %0, %0\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_test_clear\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=a"(oldbit), "=m"(*(volatile long *)ptep)
+	    : "0"(bit) );
+    return oldbit;
+}
+
+static inline pte_t
+pte_read_clear_annotate( pte_t *pteptr )
+{
+    pte_t x = {0};
+
+    __asm__ (
+	    "7777:"
+	    "xchgl %0, %1\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_read\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(x) 
+	    : "m"(*(volatile unsigned long *)pteptr), "0"(x)
+	    : "memory" );
+
+    return x;
+}
+
+
+static inline void 
+ioapic_write_annotate(unsigned int b, volatile void *addr)
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.ioapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(b), "m"(*(unsigned long *)addr) : "memory" );
+}
+
+static inline unsigned int 
+ioapic_read_annotate(const volatile void *addr)
+{
+    unsigned int temp;
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.ioapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(temp) : "m"(*(unsigned long *)addr) );
+    return temp;
+}
+
+
+static inline void 
+lapic_write_annotate(unsigned int b, volatile void *addr)
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.lapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(b), "m"(*(unsigned long *)addr) : "memory" );
+}
+
+static inline void 
+lapic_xchg_annotate(unsigned int b, volatile void *addr)
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "xchgl %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.lapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(b), "m"(*(unsigned long *)addr) : "memory" );
+}
+
+
+static inline unsigned int 
+lapic_read_annotate(const volatile void *addr)
+{
+    unsigned int temp;
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.lapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(temp) : "m"(*(unsigned long *)addr) );
+    return temp;
+}
+
+
+
+
+
+#endif /* __AFTERBURN__ANNOTATE_H__ */
diff -Naur linux-2.6.8.1.pristine/arch/i386/Kconfig linux-2.6.8.1/arch/i386/Kconfig
--- linux-2.6.8.1.pristine/arch/i386/Kconfig	2004-08-14 10:54:50.000000000 +0000
+++ linux-2.6.8.1/arch/i386/Kconfig	2006-08-16 15:51:17.000000000 +0000
@@ -867,6 +867,7 @@
 
 endmenu
 
+source "afterburn/Kconfig"
 
 menu "Power management options (ACPI, APM)"
 	depends on !X86_VOYAGER
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/Makefile linux-2.6.8.1/arch/i386/kernel/Makefile
--- linux-2.6.8.1.pristine/arch/i386/kernel/Makefile	2004-08-14 10:54:51.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/Makefile	2006-08-17 15:45:31.000000000 +0000
@@ -41,12 +41,15 @@
 # Note: kbuild does not track this dependency due to usage of .incbin
 $(obj)/vsyscall.o: $(obj)/vsyscall-int80.so $(obj)/vsyscall-sysenter.so
 targets += $(foreach F,int80 sysenter,vsyscall-$F.o vsyscall-$F.so)
+targets += vsyscall.lds
 
 # The DSO images are built using a special linker script.
 quiet_cmd_syscall = SYSCALL $@
       cmd_syscall = $(CC) -nostdlib $(SYSCFLAGS_$(@F)) \
 		          -Wl,-T,$(filter-out FORCE,$^) -o $@
 
+export CPPFLAGS_vsyscall.lds += -P -C -U$(ARCH)
+
 vsyscall-flags = -shared -s -Wl,-soname=linux-gate.so.1
 SYSCFLAGS_vsyscall-sysenter.so	= $(vsyscall-flags)
 SYSCFLAGS_vsyscall-int80.so	= $(vsyscall-flags)
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/asm-offsets.c linux-2.6.8.1/arch/i386/kernel/asm-offsets.c
--- linux-2.6.8.1.pristine/arch/i386/kernel/asm-offsets.c	2004-08-14 10:55:10.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/asm-offsets.c	2006-08-17 15:54:36.000000000 +0000
@@ -62,4 +62,5 @@
 		 sizeof(struct tss_struct));
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
+	DEFINE(VSYSCALL_BASE, __fix_to_virt(FIX_VSYSCALL));
 }
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/entry.S linux-2.6.8.1/arch/i386/kernel/entry.S
--- linux-2.6.8.1.pristine/arch/i386/kernel/entry.S	2004-08-14 10:55:09.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/entry.S	2006-08-16 15:51:17.000000000 +0000
@@ -119,7 +119,7 @@
 	.align 4;	\
 	.long 1b,3b;	\
 	.long 2b,4b;	\
-.previous
+.previous;
 
 
 #define RESTORE_ALL	\
@@ -137,7 +137,7 @@
 .section __ex_table,"a";\
 	.align 4;	\
 	.long 1b,2b;	\
-.previous
+.previous;
 
 
 
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/pci-dma.c linux-2.6.8.1/arch/i386/kernel/pci-dma.c
--- linux-2.6.8.1.pristine/arch/i386/kernel/pci-dma.c	2004-08-14 10:54:51.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/pci-dma.c	2006-08-16 15:51:17.000000000 +0000
@@ -13,6 +13,10 @@
 #include <linux/pci.h>
 #include <asm/io.h>
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+#endif
+
 void *dma_alloc_coherent(struct device *dev, size_t size,
 			   dma_addr_t *dma_handle, int gfp)
 {
@@ -27,6 +31,11 @@
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+		if (afterburn_phys_to_dma_hook)
+			*dma_handle = afterburn_phys_to_dma_hook(virt_to_phys(ret), size);
+		else
+#endif
 		*dma_handle = virt_to_phys(ret);
 	}
 	return ret;
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/signal.c linux-2.6.8.1/arch/i386/kernel/signal.c
--- linux-2.6.8.1.pristine/arch/i386/kernel/signal.c	2004-08-14 10:55:24.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/signal.c	2006-08-16 15:51:17.000000000 +0000
@@ -556,6 +556,14 @@
 	siginfo_t info;
 	int signr;
 
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+	{
+	    extern int (*afterburn_signal_hook)(void *handle);
+	    if( afterburn_signal_hook &&
+		    afterburn_signal_hook(current->afterburn_handle) )
+		goto no_signal;
+	}
+#endif
 	/*
 	 * We want the common case to go fast, which
 	 * is why we may in certain cases get here from
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/vmlinux.lds.S linux-2.6.8.1/arch/i386/kernel/vmlinux.lds.S
--- linux-2.6.8.1.pristine/arch/i386/kernel/vmlinux.lds.S	2004-08-14 10:54:51.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/vmlinux.lds.S	2006-08-17 15:31:22.000000000 +0000
@@ -4,6 +4,7 @@
 
 #include <asm-generic/vmlinux.lds.h>
 #include <asm/thread_info.h>
+#include <asm/page.h>
 
 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
 OUTPUT_ARCH(i386)
@@ -11,7 +12,7 @@
 jiffies = jiffies_64;
 SECTIONS
 {
-  . = 0xC0000000 + 0x100000;
+  . = __PAGE_OFFSET + 0x100000;
   /* read-only */
   _text = .;			/* Text and read-only data */
   .text : {
@@ -36,6 +37,10 @@
 	CONSTRUCTORS
 	}
 
+  __burn_prof_counters_start = .;
+  .burn_prof_counters : { *(.burn_prof_counters) }
+  __burn_prof_counters_end = .;
+
   . = ALIGN(4096);
   __nosave_begin = .;
   .data_nosave : { *(.data.nosave) }
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/vsyscall.lds linux-2.6.8.1/arch/i386/kernel/vsyscall.lds
--- linux-2.6.8.1.pristine/arch/i386/kernel/vsyscall.lds	2004-08-14 10:55:19.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/vsyscall.lds	1970-01-01 00:00:00.000000000 +0000
@@ -1,67 +0,0 @@
-/*
- * Linker script for vsyscall DSO.  The vsyscall page is an ELF shared
- * object prelinked to its virtual address, and with only one read-only
- * segment (that fits in one page).  This script controls its layout.
- */
-
-/* This must match <asm/fixmap.h>.  */
-VSYSCALL_BASE = 0xffffe000;
-
-SECTIONS
-{
-  . = VSYSCALL_BASE + SIZEOF_HEADERS;
-
-  .hash           : { *(.hash) }		:text
-  .dynsym         : { *(.dynsym) }
-  .dynstr         : { *(.dynstr) }
-  .gnu.version    : { *(.gnu.version) }
-  .gnu.version_d  : { *(.gnu.version_d) }
-  .gnu.version_r  : { *(.gnu.version_r) }
-
-  /* This linker script is used both with -r and with -shared.
-     For the layouts to match, we need to skip more than enough
-     space for the dynamic symbol table et al.  If this amount
-     is insufficient, ld -shared will barf.  Just increase it here.  */
-  . = VSYSCALL_BASE + 0x400;
-
-  .text           : { *(.text) }		:text =0x90909090
-
-  .eh_frame_hdr   : { *(.eh_frame_hdr) }	:text :eh_frame_hdr
-  .eh_frame       : { KEEP (*(.eh_frame)) }	:text
-  .dynamic        : { *(.dynamic) }		:text :dynamic
-  .useless        : {
-  	*(.got.plt) *(.got)
-	*(.data .data.* .gnu.linkonce.d.*)
-	*(.dynbss)
-	*(.bss .bss.* .gnu.linkonce.b.*)
-  }						:text
-}
-
-/*
- * We must supply the ELF program headers explicitly to get just one
- * PT_LOAD segment, and set the flags explicitly to make segments read-only.
- */
-PHDRS
-{
-  text PT_LOAD FILEHDR PHDRS FLAGS(5); /* PF_R|PF_X */
-  dynamic PT_DYNAMIC FLAGS(4); /* PF_R */
-  eh_frame_hdr 0x6474e550; /* PT_GNU_EH_FRAME, but ld doesn't match the name */
-}
-
-/*
- * This controls what symbols we export from the DSO.
- */
-VERSION
-{
-  LINUX_2.5 {
-    global:
-    	__kernel_vsyscall;
-    	__kernel_sigreturn;
-    	__kernel_rt_sigreturn;
-
-    local: *;
-  };
-}
-
-/* The ELF entry point can be used to set the AT_SYSINFO value.  */
-ENTRY(__kernel_vsyscall);
diff -Naur linux-2.6.8.1.pristine/arch/i386/kernel/vsyscall.lds.S linux-2.6.8.1/arch/i386/kernel/vsyscall.lds.S
--- linux-2.6.8.1.pristine/arch/i386/kernel/vsyscall.lds.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8.1/arch/i386/kernel/vsyscall.lds.S	2006-08-17 15:46:10.000000000 +0000
@@ -0,0 +1,65 @@
+/*
+ * Linker script for vsyscall DSO.  The vsyscall page is an ELF shared
+ * object prelinked to its virtual address, and with only one read-only
+ * segment (that fits in one page).  This script controls its layout.
+ */
+#include <asm/asm_offsets.h>
+
+SECTIONS
+{
+  . = VSYSCALL_BASE + SIZEOF_HEADERS;
+
+  .hash           : { *(.hash) }		:text
+  .dynsym         : { *(.dynsym) }
+  .dynstr         : { *(.dynstr) }
+  .gnu.version    : { *(.gnu.version) }
+  .gnu.version_d  : { *(.gnu.version_d) }
+  .gnu.version_r  : { *(.gnu.version_r) }
+
+  /* This linker script is used both with -r and with -shared.
+     For the layouts to match, we need to skip more than enough
+     space for the dynamic symbol table et al.  If this amount
+     is insufficient, ld -shared will barf.  Just increase it here.  */
+  . = VSYSCALL_BASE + 0x400;
+
+  .text           : { *(.text) }		:text =0x90909090
+
+  .eh_frame_hdr   : { *(.eh_frame_hdr) }	:text :eh_frame_hdr
+  .eh_frame       : { KEEP (*(.eh_frame)) }	:text
+  .dynamic        : { *(.dynamic) }		:text :dynamic
+  .useless        : {
+  	*(.got.plt) *(.got)
+	*(.data .data.* .gnu.linkonce.d.*)
+	*(.dynbss)
+	*(.bss .bss.* .gnu.linkonce.b.*)
+  }						:text
+}
+
+/*
+ * We must supply the ELF program headers explicitly to get just one
+ * PT_LOAD segment, and set the flags explicitly to make segments read-only.
+ */
+PHDRS
+{
+  text PT_LOAD FILEHDR PHDRS FLAGS(5); /* PF_R|PF_X */
+  dynamic PT_DYNAMIC FLAGS(4); /* PF_R */
+  eh_frame_hdr 0x6474e550; /* PT_GNU_EH_FRAME, but ld doesn't match the name */
+}
+
+/*
+ * This controls what symbols we export from the DSO.
+ */
+VERSION
+{
+  LINUX_2.5 {
+    global:
+    	__kernel_vsyscall;
+    	__kernel_sigreturn;
+    	__kernel_rt_sigreturn;
+
+    local: *;
+  };
+}
+
+/* The ELF entry point can be used to set the AT_SYSINFO value.  */
+ENTRY(__kernel_vsyscall);
diff -Naur linux-2.6.8.1.pristine/arch/i386/lib/usercopy.c linux-2.6.8.1/arch/i386/lib/usercopy.c
--- linux-2.6.8.1.pristine/arch/i386/lib/usercopy.c	2004-08-14 10:54:46.000000000 +0000
+++ linux-2.6.8.1/arch/i386/lib/usercopy.c	2006-08-16 15:51:17.000000000 +0000
@@ -13,6 +13,12 @@
 #include <asm/uaccess.h>
 #include <asm/mmx.h>
 
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+extern unsigned long (*afterburn_clear_user_hook)(void *to, unsigned long n);
+extern unsigned long (*afterburn_strnlen_user_hook)(const char *s, unsigned long n);
+extern unsigned long (*afterburn_strncpy_from_user_hook)(char *dst, const char *src, unsigned long n, unsigned long *success);
+#endif
+
 static inline int __movsl_is_ok(unsigned long a1, unsigned long a2, unsigned long n)
 {
 #ifdef CONFIG_X86_INTEL_USERCOPY
@@ -80,6 +86,15 @@
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	long res;
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_strncpy_from_user_hook ) {
+		unsigned long success;
+		res = afterburn_strncpy_from_user_hook( dst, src, count, &success );
+		if( !success )
+			return -EFAULT;
+		return res;
+	}
+#endif
 	__do_strncpy_from_user(dst, src, count, res);
 	return res;
 }
@@ -106,8 +121,18 @@
 strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	long res = -EFAULT;
-	if (access_ok(VERIFY_READ, src, 1))
+	if (access_ok(VERIFY_READ, src, 1)) {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+		if( afterburn_strncpy_from_user_hook ) {
+			unsigned long success;
+			res = afterburn_strncpy_from_user_hook( dst, src, count, &success );
+			if( !success )
+				return -EFAULT;
+			return res;
+		}
+#endif
 		__do_strncpy_from_user(dst, src, count, res);
+	}
 	return res;
 }
 
@@ -150,6 +175,10 @@
 unsigned long
 clear_user(void __user *to, unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_clear_user_hook )
+		return n - afterburn_clear_user_hook( to, n );
+#endif
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, to, n))
 		__do_clear_user(to, n);
@@ -170,6 +199,10 @@
 unsigned long
 __clear_user(void __user *to, unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_clear_user_hook )
+		return n - afterburn_clear_user_hook( to, n );
+#endif
 	__do_clear_user(to, n);
 	return n;
 }
@@ -192,6 +225,11 @@
 
 	might_sleep();
 
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_strnlen_user_hook )
+		return afterburn_strnlen_user_hook( s, n );
+#endif
+
 	__asm__ __volatile__(
 		"	testl %0, %0\n"
 		"	jz 3f\n"
@@ -512,6 +550,11 @@
 
 unsigned long __copy_to_user_ll(void __user *to, const void *from, unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_copy_to_user_hook )
+		return n - afterburn_copy_to_user_hook( to, from, n );
+#endif
+
 #ifndef CONFIG_X86_WP_WORKS_OK
 	if (unlikely(boot_cpu_data.wp_works_ok == 0) &&
 			((unsigned long )to) < TASK_SIZE) {
@@ -571,6 +614,10 @@
 unsigned long
 __copy_from_user_ll(void *to, const void __user *from, unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_copy_from_user_hook )
+		return n - afterburn_copy_from_user_hook( to, from, n );
+#endif
 	if (movsl_is_ok(to, from, n))
 		__copy_user_zeroing(to, from, n);
 	else
diff -Naur linux-2.6.8.1.pristine/arch/i386/mm/init.c linux-2.6.8.1/arch/i386/mm/init.c
--- linux-2.6.8.1.pristine/arch/i386/mm/init.c	2004-08-14 10:55:48.000000000 +0000
+++ linux-2.6.8.1/arch/i386/mm/init.c	2006-08-16 15:51:17.000000000 +0000
@@ -331,7 +331,7 @@
 	 * created - mappings will be set by set_fixmap():
 	 */
 	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
-	page_table_range_init(vaddr, 0, pgd_base);
+	page_table_range_init(vaddr, vaddr + PMD_SIZE, pgd_base);
 
 	permanent_kmaps_init(pgd_base);
 
@@ -343,7 +343,7 @@
 	 * All user-space mappings are explicitly cleared after
 	 * SMP startup.
 	 */
-	pgd_base[0] = pgd_base[USER_PTRS_PER_PGD];
+	pgd_base[0] = pgd_base[USER_PGD_PTRS];
 #endif
 }
 
@@ -377,7 +377,7 @@
 	 * Note that "pgd_clear()" doesn't do it for
 	 * us, because pgd_clear() is a no-op on i386.
 	 */
-	for (i = 0; i < USER_PTRS_PER_PGD; i++)
+	for (i = 0; i < USER_PGD_PTRS; i++)
 #ifdef CONFIG_X86_PAE
 		set_pgd(swapper_pg_dir+i, __pgd(1 + __pa(empty_zero_page)));
 #else
diff -Naur linux-2.6.8.1.pristine/drivers/net/ns83820.c linux-2.6.8.1/drivers/net/ns83820.c
--- linux-2.6.8.1.pristine/drivers/net/ns83820.c	2004-08-14 10:56:23.000000000 +0000
+++ linux-2.6.8.1/drivers/net/ns83820.c	2006-08-16 15:51:17.000000000 +0000
@@ -92,9 +92,17 @@
 //#define dprintk		printk
 #define dprintk(x...)		do { } while (0)
 
+
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/pci.h>
+
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define readl dp83820_read_annotate
+#define writel dp83820_write_annotate
+#endif
+
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/delay.h>
@@ -573,6 +581,12 @@
 		struct sk_buff *skb;
 		long res;
 		/* extra 16 bytes for alignment */
+#if 0
+		skb = __dev_alloc_skb(REAL_RX_BUF_SIZE+NET_IP_ALIGN, gfp);
+		if (unlikely(!skb))
+			break;
+		skb_reserve(skb,NET_IP_ALIGN);
+#else
 		skb = __dev_alloc_skb(REAL_RX_BUF_SIZE+16, gfp);
 		if (unlikely(!skb))
 			break;
@@ -581,6 +595,7 @@
 		res = 0x10 - res;
 		res &= 0xf;
 		skb_reserve(skb, res);
+#endif
 
 		skb->dev = ndev;
 		if (gfp != GFP_ATOMIC)
diff -Naur linux-2.6.8.1.pristine/fs/mpage.c linux-2.6.8.1/fs/mpage.c
--- linux-2.6.8.1.pristine/fs/mpage.c	2004-08-14 10:54:51.000000000 +0000
+++ linux-2.6.8.1/fs/mpage.c	2006-08-16 15:51:17.000000000 +0000
@@ -635,8 +635,11 @@
 	}
 
 	writepage = NULL;
-	if (get_block == NULL)
+	if (get_block == NULL) {
 		writepage = mapping->a_ops->writepage;
+		if (writepage == NULL)
+			return ret;
+	}
 
 	pagevec_init(&pvec, 0);
 	if (wbc->sync_mode == WB_SYNC_NONE) {
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/apic.h linux-2.6.8.1/include/asm-i386/apic.h
--- linux-2.6.8.1.pristine/include/asm-i386/apic.h	2004-08-14 10:56:23.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/apic.h	2006-08-16 15:55:18.000000000 +0000
@@ -17,23 +17,35 @@
 
 #ifdef CONFIG_X86_LOCAL_APIC
 
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define __apic_read                   lapic_read_annotate
+#define __apic_write                  lapic_write_annotate
+#define __apic_write_atomic           lapic_xchg_annotate
+#else
+#define __apic_read(a)                *(a)
+#define __apic_write(v,a)             *(a) = v
+#define __apic_write_atomic(v,a)      xchg(a, v)
+#endif
+
 /*
  * Basic functions accessing APICs.
  */
 
 static __inline void apic_write(unsigned long reg, unsigned long v)
 {
-	*((volatile unsigned long *)(APIC_BASE+reg)) = v;
+	__apic_write(v, (volatile unsigned long *)(APIC_BASE+reg));
 }
 
 static __inline void apic_write_atomic(unsigned long reg, unsigned long v)
 {
-	xchg((volatile unsigned long *)(APIC_BASE+reg), v);
+	__apic_write_atomic(v, (volatile unsigned long *)(APIC_BASE+reg));
 }
 
 static __inline unsigned long apic_read(unsigned long reg)
 {
-	return *((volatile unsigned long *)(APIC_BASE+reg));
+	
+	return __apic_read((volatile unsigned long *)(APIC_BASE+reg));
 }
 
 static __inline__ void apic_wait_icr_idle(void)
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/dma-mapping.h linux-2.6.8.1/include/asm-i386/dma-mapping.h
--- linux-2.6.8.1.pristine/include/asm-i386/dma-mapping.h	2004-08-14 10:56:24.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/dma-mapping.h	2006-08-16 15:51:17.000000000 +0000
@@ -8,6 +8,10 @@
 #include <asm/io.h>
 #include <asm/scatterlist.h>
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+#endif
+
 #define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 #define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 
@@ -23,6 +27,10 @@
 {
 	BUG_ON(direction == DMA_NONE);
 	flush_write_buffers();
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(virt_to_phys(ptr), size);
+#endif
 	return virt_to_phys(ptr);
 }
 
@@ -44,6 +52,11 @@
 	for (i = 0; i < nents; i++ ) {
 		BUG_ON(!sg[i].page);
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+		if (afterburn_phys_to_dma_hook)
+			sg[i].dma_address = afterburn_phys_to_dma_hook(page_to_phys(sg[i].page), sg[i].length) + sg[i].offset;
+		else
+#endif
 		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
 	}
 
@@ -56,6 +69,10 @@
 	     size_t size, enum dma_data_direction direction)
 {
 	BUG_ON(direction == DMA_NONE);
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(page_to_phys(page), PAGE_SIZE) + offset;
+#endif
 	return page_to_phys(page) + offset;
 }
 
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/fixmap.h linux-2.6.8.1/include/asm-i386/fixmap.h
--- linux-2.6.8.1.pristine/include/asm-i386/fixmap.h	2004-08-14 10:54:48.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/fixmap.h	2006-08-16 15:57:06.000000000 +0000
@@ -103,7 +103,11 @@
  * Leave one empty page between vmalloc'ed areas and
  * the start of the fixmap.
  */
+#if defined(CONFIG_AFTERBURN_RELINK)
+#define FIXADDR_TOP ((unsigned long)CONFIG_AFTERBURN_VADDR_END-0x1000)
+#else
 #define FIXADDR_TOP	(0xfffff000UL)
+#endif
 #define __FIXADDR_SIZE	(__end_of_permanent_fixed_addresses << PAGE_SHIFT)
 #define FIXADDR_START	(FIXADDR_TOP - __FIXADDR_SIZE)
 
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/io.h linux-2.6.8.1/include/asm-i386/io.h
--- linux-2.6.8.1.pristine/include/asm-i386/io.h	2004-08-14 10:56:23.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/io.h	2006-08-16 15:58:00.000000000 +0000
@@ -43,6 +43,12 @@
 
 #ifdef __KERNEL__
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+extern unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+extern unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+#include <linux/mm.h>
+#endif
+
 #include <linux/vmalloc.h>
 
 /**
@@ -119,6 +125,36 @@
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
  */
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+static inline unsigned long virt_to_bus( void * virt )
+{
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(virt_to_phys(virt),PAGE_SIZE);
+	else
+		return virt_to_phys(virt);
+}
+
+static inline void * bus_to_virt( unsigned long bus )
+{
+	if (afterburn_dma_to_phys_hook)
+		return phys_to_virt(afterburn_dma_to_phys_hook(bus));
+	else
+		return phys_to_virt(bus);
+}
+
+static inline unsigned long page_to_bus( struct page *page )
+{
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(page_to_phys(page),PAGE_SIZE);
+	else
+		return page_to_phys(page);
+}
+
+#define isa_virt_to_bus virt_to_bus
+#define isa_page_to_bus page_to_bus
+#define isa_bus_to_virt bus_to_virt
+
+#else
 #define isa_virt_to_bus virt_to_phys
 #define isa_page_to_bus page_to_phys
 #define isa_bus_to_virt phys_to_virt
@@ -131,6 +167,7 @@
  */
 #define virt_to_bus virt_to_phys
 #define bus_to_virt phys_to_virt
+#endif
 
 /*
  * readX/writeX() are used to access memory mapped devices. On some
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/io_apic.h linux-2.6.8.1/include/asm-i386/io_apic.h
--- linux-2.6.8.1.pristine/include/asm-i386/io_apic.h	2004-08-14 10:55:47.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/io_apic.h	2006-08-16 15:51:17.000000000 +0000
@@ -162,16 +162,26 @@
 /* non-0 if default (table-less) MP configuration */
 extern int mpc_default_type;
 
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define __io_apic_read			ioapic_read_annotate
+#define __io_apic_write			ioapic_write_annotate
+#else
+#define __io_apic_read(a)		*(a)
+#define __io_apic_write(v,a)            *(a) = v
+
+#endif
+
 static inline unsigned int io_apic_read(unsigned int apic, unsigned int reg)
 {
-	*IO_APIC_BASE(apic) = reg;
-	return *(IO_APIC_BASE(apic)+4);
+	__io_apic_write(reg, IO_APIC_BASE(apic));
+	return __io_apic_read(IO_APIC_BASE(apic)+4);
 }
 
 static inline void io_apic_write(unsigned int apic, unsigned int reg, unsigned int value)
 {
-	*IO_APIC_BASE(apic) = reg;
-	*(IO_APIC_BASE(apic)+4) = value;
+	__io_apic_write(reg, IO_APIC_BASE(apic));
+	__io_apic_write(value, IO_APIC_BASE(apic)+4);
 }
 
 /*
@@ -184,8 +194,9 @@
 static inline void io_apic_modify(unsigned int apic, unsigned int reg, unsigned int value)
 {
 	if (sis_apic_bug)
-		*IO_APIC_BASE(apic) = reg;
-	*(IO_APIC_BASE(apic)+4) = value;
+	    __io_apic_write(reg, IO_APIC_BASE(apic));
+
+	__io_apic_write(value, IO_APIC_BASE(apic)+4);
 }
 
 /* 1 if "noapic" boot option passed */
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/page.h linux-2.6.8.1/include/asm-i386/page.h
--- linux-2.6.8.1.pristine/include/asm-i386/page.h	2004-08-14 10:54:50.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/page.h	2006-08-16 15:51:17.000000000 +0000
@@ -67,8 +67,14 @@
 #endif
 
 
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+#define pmd_val(x) pgd_read_annotate( (x).pmd )
+#define pgd_val(x) pgd_read_annotate( (x).pgd )
+#else
 #define pmd_val(x)	((x).pmd)
 #define pgd_val(x)	((x).pgd)
+#endif
+
 #define pgprot_val(x)	((x).pgprot)
 
 #define __pte(x) ((pte_t) { (x) } )
@@ -118,16 +124,25 @@
 
 #endif /* __ASSEMBLY__ */
 
-#ifdef __ASSEMBLY__
-#define __PAGE_OFFSET		(0xC0000000)
+#if defined(CONFIG_AFTERBURN_RELINK)
+# ifdef __ASSEMBLY__
+# define __PAGE_OFFSET		(CONFIG_AFTERBURN_LINK_BASE)
+# else
+# define __PAGE_OFFSET		((unsigned long)CONFIG_AFTERBURN_LINK_BASE)
+# endif
+# define MAXMEM			(CONFIG_AFTERBURN_VADDR_END-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #else
-#define __PAGE_OFFSET		(0xC0000000UL)
+# ifdef __ASSEMBLY__
+# define __PAGE_OFFSET		(0xC0000000)
+# else
+# define __PAGE_OFFSET		(0xC0000000UL)
+# endif
+# define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #endif
 
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
-#define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
 #define pfn_to_kaddr(pfn)      __va((pfn) << PAGE_SHIFT)
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/param.h linux-2.6.8.1/include/asm-i386/param.h
--- linux-2.6.8.1.pristine/include/asm-i386/param.h	2004-08-14 10:54:51.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/param.h	2006-08-16 15:51:17.000000000 +0000
@@ -1,8 +1,14 @@
 #ifndef _ASMi386_PARAM_H
 #define _ASMi386_PARAM_H
 
+#include <linux/config.h>
+
 #ifdef __KERNEL__
-# define HZ		1000		/* Internal kernel timer frequency */
+#if defined(CONFIG_AFTERBURN)
+# define HZ		100		/* Internal kernel timer frequency */
+#else
+# define HZ		100		/* Internal kernel timer frequency */
+#endif
 # define USER_HZ	100		/* .. some user interfaces are in "ticks" */
 # define CLOCKS_PER_SEC		(USER_HZ)	/* like times() */
 #endif
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/pci.h linux-2.6.8.1/include/asm-i386/pci.h
--- linux-2.6.8.1.pristine/include/asm-i386/pci.h	2004-08-14 10:55:19.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/pci.h	2006-08-17 16:03:30.000000000 +0000
@@ -63,13 +63,22 @@
 static inline dma64_addr_t
 pci_dac_page_to_dma(struct pci_dev *pdev, struct page *page, unsigned long offset, int direction)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+	return ((dma64_addr_t) page_to_bus(page) +
+		(dma64_addr_t) offset);
+#else
 	return ((dma64_addr_t) page_to_phys(page) +
 		(dma64_addr_t) offset);
+#endif
 }
 
 static inline struct page *
 pci_dac_dma_to_page(struct pci_dev *pdev, dma64_addr_t dma_addr)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+	if (afterburn_dma_to_phys_hook)
+	    return pfn_to_page(afterburn_dma_to_phys_hook(dma_addr) >> PAGE_SHIFT);
+#endif
 	return pfn_to_page(dma_addr >> PAGE_SHIFT);
 }
 
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/pgtable-2level.h linux-2.6.8.1/include/asm-i386/pgtable-2level.h
--- linux-2.6.8.1.pristine/include/asm-i386/pgtable-2level.h	2004-08-14 10:55:33.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/pgtable-2level.h	2006-08-16 15:51:17.000000000 +0000
@@ -23,6 +23,15 @@
  * within a page table are directly modified.  Thus, the following
  * hook is made available.
  */
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define set_pte(pteptr, pteval) pte_set_annotate( (pte_t *)(pteptr), (pteval).pte_low )
+#define set_pgd(pgdptr, pgdval) pgd_set_annotate( (pgd_t *)(pgdptr), (pgdval).pgd )
+#define set_pmd(pmdptr, pmdval) pmd_set_annotate( (pmd_t *)(pmdptr), (pmdval).pmd )
+#define set_pte_atomic(pteptr, pteval) set_pte(pteptr,pteval)
+
+#else
+
 #define set_pte(pteptr, pteval) (*(pteptr) = pteval)
 #define set_pte_atomic(pteptr, pteval) set_pte(pteptr,pteval)
 /*
@@ -31,6 +40,7 @@
  */
 #define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
 #define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+#endif
 
 #define pgd_page(pgd) \
 ((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
@@ -39,11 +49,22 @@
 {
 	return (pmd_t *) dir;
 }
-#define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte_low, 0))
+static inline pte_t ptep_get_and_clear(pte_t *ptep)
+{
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+	return pte_read_clear_annotate(ptep);
+#endif
+	return __pte(xchg(&ptep->pte_low, 0));
+}
 #define pte_same(a, b)		((a).pte_low == (b).pte_low)
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
 #define pte_none(x)		(!(x).pte_low)
-#define pte_pfn(x)		((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+#include "../../afterburn/annotate.h"
+#define pte_pfn(x)		((unsigned long)(((pte_read_annotate(pte_val(x))) >> PAGE_SHIFT)))
+#else
+#define pte_pfn(x)		((unsigned long)(((pte_val(x)) >> PAGE_SHIFT)))
+#endif
 #define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/pgtable.h linux-2.6.8.1/include/asm-i386/pgtable.h
--- linux-2.6.8.1.pristine/include/asm-i386/pgtable.h	2004-08-14 10:55:48.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/pgtable.h	2006-08-16 15:51:17.000000000 +0000
@@ -208,7 +208,6 @@
 #define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
 #define	pmd_bad(x)	((pmd_val(x) & (~PAGE_MASK & ~_PAGE_USER)) != _KERNPG_TABLE)
 
-
 #define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
 
 /*
@@ -243,8 +242,15 @@
 # include <asm/pgtable-2level.h>
 #endif
 
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#endif
+
 static inline int ptep_test_and_clear_dirty(pte_t *ptep)
 {
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+	return pte_test_and_clear_bit_annotate( _PAGE_BIT_DIRTY, ptep );
+#endif
 	if (!pte_dirty(*ptep))
 		return 0;
 	return test_and_clear_bit(_PAGE_BIT_DIRTY, &ptep->pte_low);
@@ -252,12 +258,22 @@
 
 static inline int ptep_test_and_clear_young(pte_t *ptep)
 {
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+	return pte_test_and_clear_bit_annotate( _PAGE_BIT_ACCESSED, ptep );
+#endif
 	if (!pte_young(*ptep))
 		return 0;
 	return test_and_clear_bit(_PAGE_BIT_ACCESSED, &ptep->pte_low);
 }
 
-static inline void ptep_set_wrprotect(pte_t *ptep)		{ clear_bit(_PAGE_BIT_RW, &ptep->pte_low); }
+static inline void ptep_set_wrprotect(pte_t *ptep)		
+{
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+	pte_test_and_clear_bit_annotate( _PAGE_BIT_RW, ptep );
+	return;
+#endif
+	clear_bit(_PAGE_BIT_RW, &ptep->pte_low); 
+}
 static inline void ptep_mkdirty(pte_t *ptep)			{ set_bit(_PAGE_BIT_DIRTY, &ptep->pte_low); }
 
 /*
@@ -393,7 +409,7 @@
 #define ptep_set_access_flags(__vma, __address, __ptep, __entry, __dirty) \
 	do {								  \
 		if (__dirty) {						  \
-			(__ptep)->pte_low = (__entry).pte_low;	  	  \
+			set_pte(__ptep, __entry);                         \
 			flush_tlb_page(__vma, __address);		  \
 		}							  \
 	} while (0)
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/processor.h linux-2.6.8.1/include/asm-i386/processor.h
--- linux-2.6.8.1.pristine/include/asm-i386/processor.h	2004-08-14 10:54:48.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/processor.h	2006-08-16 15:51:17.000000000 +0000
@@ -289,7 +289,11 @@
 /*
  * User space process size: 3GB (default).
  */
+#if defined(CONFIG_AFTERBURN)
+#define TASK_SIZE	(CONFIG_AFTERBURN_USER_VADDR_END)
+#else
 #define TASK_SIZE	(PAGE_OFFSET)
+#endif
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
@@ -449,6 +453,13 @@
 static inline void load_esp0(struct tss_struct *tss, struct thread_struct *thread)
 {
 	tss->esp0 = thread->esp0;
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+	{
+	    extern void (*afterburn_sync_esp0)( void );
+	    if( afterburn_sync_esp0 )
+		afterburn_sync_esp0();
+	}
+#endif
 	/* This can only happen when SEP is enabled, no need to test "SEP"arately */
 	if (unlikely(tss->ss1 != thread->sysenter_cs)) {
 		tss->ss1 = thread->sysenter_cs;
diff -Naur linux-2.6.8.1.pristine/include/asm-i386/uaccess.h linux-2.6.8.1/include/asm-i386/uaccess.h
--- linux-2.6.8.1.pristine/include/asm-i386/uaccess.h	2004-08-14 10:54:50.000000000 +0000
+++ linux-2.6.8.1/include/asm-i386/uaccess.h	2006-08-16 15:51:17.000000000 +0000
@@ -24,6 +24,15 @@
 
 #define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
 
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+#define ON_AFTERBURN_HOOK_UACCESS(a) a
+extern unsigned long (*afterburn_get_user_hook)(void *to, const void *from, unsigned long n);
+extern unsigned long (*afterburn_put_user_hook)(void *to, const void *from, unsigned long n);
+extern unsigned long (*afterburn_copy_from_user_hook)(void *to, const void *from, unsigned long n);
+extern unsigned long (*afterburn_copy_to_user_hook)(void *to, const void *from, unsigned long n);
+#else
+#define ON_AFTERBURN_HOOK_UACCESS(a)
+#endif
 
 #define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFFUL)
 #define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
@@ -172,12 +181,23 @@
 #define get_user(x,ptr)							\
 ({	int __ret_gu,__val_gu;						\
 	__chk_user_ptr(ptr);						\
+ON_AFTERBURN_HOOK_UACCESS(						\
+	if(afterburn_get_user_hook) { 					\
+		if(unlikely(!__addr_ok(ptr)))				\
+			__ret_gu = 0;					\
+		else							\
+			__ret_gu = afterburn_get_user_hook(&__val_gu, ptr, sizeof(*(ptr)));\
+		if(likely(__ret_gu == sizeof(*(ptr)))) __ret_gu = 0;	\
+		else { __ret_gu = -EFAULT; __val_gu = 0; }		\
+	} else {							\
+)									\
 	switch(sizeof (*(ptr))) {					\
 	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
 	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
 	case 4:  __get_user_x(4,__ret_gu,__val_gu,ptr); break;		\
 	default: __get_user_x(X,__ret_gu,__val_gu,ptr); break;		\
 	}								\
+ON_AFTERBURN_HOOK_UACCESS( } )						\
 	(x) = (__typeof__(*(ptr)))__val_gu;				\
 	__ret_gu;							\
 })
@@ -291,6 +311,13 @@
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+ON_AFTERBURN_HOOK_UACCESS(						\
+	if(afterburn_put_user_hook) {					\
+		__typeof__(*(ptr)) __pus_tmp = x; 			\
+		if(unlikely(!afterburn_put_user_hook(ptr, &__pus_tmp, size))) \
+			retval = errret;				\
+	} else {							\
+)									\
 	switch (size) {							\
 	case 1: __put_user_asm(x,ptr,retval,"b","b","iq",errret);break;	\
 	case 2: __put_user_asm(x,ptr,retval,"w","w","ir",errret);break; \
@@ -298,6 +325,7 @@
 	case 8: __put_user_u64((__typeof__(*ptr))(x),ptr,retval); break;\
 	  default: __put_user_bad();					\
 	}								\
+ON_AFTERBURN_HOOK_UACCESS( } )						\
 } while (0)
 
 #else
@@ -350,12 +378,20 @@
 do {									\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
+ON_AFTERBURN_HOOK_UACCESS(						\
+	if(afterburn_get_user_hook) {					\
+		if(unlikely(!afterburn_get_user_hook(&(x), ptr, size)))	\
+			{ (x) = 0; retval = errret; }			\
+	}								\
+	else {								\
+)									\
 	switch (size) {							\
 	case 1: __get_user_asm(x,ptr,retval,"b","b","=q",errret);break;	\
 	case 2: __get_user_asm(x,ptr,retval,"w","w","=r",errret);break;	\
 	case 4: __get_user_asm(x,ptr,retval,"l","","=r",errret);break;	\
 	default: (x) = __get_user_bad();				\
 	}								\
+ON_AFTERBURN_HOOK_UACCESS( } )						\
 } while (0)
 
 #define __get_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
diff -Naur linux-2.6.8.1.pristine/include/linux/sched.h linux-2.6.8.1/include/linux/sched.h
--- linux-2.6.8.1.pristine/include/linux/sched.h	2004-08-14 10:54:49.000000000 +0000
+++ linux-2.6.8.1/include/linux/sched.h	2006-08-16 16:02:27.000000000 +0000
@@ -408,6 +408,10 @@
 	unsigned long policy;
 	cpumask_t cpus_allowed;
 	unsigned int time_slice, first_time_slice;
+#ifdef CONFIG_AFTERBURN_THREAD_HOOKS
+	void * afterburn_handle;
+#endif
+
 
 	struct list_head tasks;
 	/*
@@ -674,6 +678,9 @@
 	.nr_balance_failed	= 0,			\
 }
 #endif
+#ifdef CONFIG_AFTERBURN_THREAD_HOOKS
+	void * afterburn_handle;
+#endif
 
 extern void cpu_attach_domain(struct sched_domain *sd, int cpu);
 
diff -Naur linux-2.6.8.1.pristine/init/Kconfig linux-2.6.8.1/init/Kconfig
--- linux-2.6.8.1.pristine/init/Kconfig	2004-08-14 10:55:59.000000000 +0000
+++ linux-2.6.8.1/init/Kconfig	2006-08-17 16:11:06.000000000 +0000
@@ -56,6 +56,16 @@
 
 menu "General setup"
 
+config LOCALVERSION
+	string "Local version - append to kernel release"
+	help
+	  Append an extra string to the end of your kernel version.
+	  This will show up when you type uname, for example.
+	  The string you set here will be appended after the contents of
+	  any files with a filename matching localversion* in your
+	  object and source tree, in that order.  Your total string can
+	  be a maximum of 64 characters.
+
 config SWAP
 	bool "Support for paging of anonymous memory (swap)"
 	depends on MMU
diff -Naur linux-2.6.8.1.pristine/kernel/exit.c linux-2.6.8.1/kernel/exit.c
--- linux-2.6.8.1.pristine/kernel/exit.c	2004-08-14 10:56:01.000000000 +0000
+++ linux-2.6.8.1/kernel/exit.c	2006-08-16 15:51:17.000000000 +0000
@@ -828,6 +828,12 @@
 	__exit_fs(tsk);
 	exit_namespace(tsk);
 	exit_thread();
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+	{
+		extern void (*afterburn_exit_hook)( void * handle );
+		afterburn_exit_hook(tsk->afterburn_handle);
+	}
+#endif
 
 	if (tsk->signal->leader)
 		disassociate_ctty(1);
diff -Naur linux-2.6.8.1.pristine/kernel/fork.c linux-2.6.8.1/kernel/fork.c
--- linux-2.6.8.1.pristine/kernel/fork.c	2004-08-14 10:54:49.000000000 +0000
+++ linux-2.6.8.1/kernel/fork.c	2006-08-16 15:51:17.000000000 +0000
@@ -943,6 +943,10 @@
 
 	p->proc_dentry = NULL;
 
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+	p->afterburn_handle = NULL;
+#endif
+
 	INIT_LIST_HEAD(&p->children);
 	INIT_LIST_HEAD(&p->sibling);
 	init_waitqueue_head(&p->wait_chldexit);
diff -Naur linux-2.6.8.1.pristine/kernel/module.c linux-2.6.8.1/kernel/module.c
--- linux-2.6.8.1.pristine/kernel/module.c	2004-08-14 10:55:48.000000000 +0000
+++ linux-2.6.8.1/kernel/module.c	2006-09-01 13:23:01.000000000 +0000
@@ -1708,6 +1708,17 @@
 		DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);
 	}
 	/* Module has been moved. */
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+	{
+	    extern int (*afterburn_rewrite_module_hook)(Elf_Ehdr *);
+	    if( afterburn_rewrite_module_hook && 
+		    !afterburn_rewrite_module_hook(hdr) ) {
+	       	err = -ENOEXEC;
+    		goto cleanup;
+	    }
+	}
+#endif
+
 	mod = (void *)sechdrs[modindex].sh_addr;
 
 	/* Now we've moved module, initialize linked lists, etc. */
diff -Naur linux-2.6.8.1.pristine/scripts/Makefile.build linux-2.6.8.1/scripts/Makefile.build
--- linux-2.6.8.1.pristine/scripts/Makefile.build	2004-08-14 10:55:59.000000000 +0000
+++ linux-2.6.8.1/scripts/Makefile.build	2006-08-17 15:47:58.000000000 +0000
@@ -126,7 +126,15 @@
 quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
 
 ifndef CONFIG_MODVERSIONS
+ifndef CONFIG_AFTERBURN
 cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
+else
+params_afterburner-$(CONFIG_AFTERBURN_KERNEL_PROFILING) = -p
+params_cc_o_c-$(CONFIG_AFTERBURN_KERNEL_PROFILING) = -pg
+cmd_cc_o_c  = $(CC) $(c_flags) -c -S $(params_cc_o_c-y) -o $(@D)/.preburn_$(@F:.o=.s) $< 
+cmd_cc_o_c += && afterburner $(params_afterburner-y) $(@D)/.preburn_$(@F:.o=.s) > $(@D)/.afterburnt_$(@F:.o=.s)
+cmd_cc_o_c += && $(CC) $(filter-out -g,$(c_flags)) -c -o $@ $(@D)/.afterburnt_$(@F:.o=.s)
+endif
 
 else
 # When module versioning is enabled the following steps are executed:
@@ -201,7 +209,13 @@
 	$(call if_changed_dep,as_s_S)
 
 quiet_cmd_as_o_S = AS $(quiet_modtag)  $@
+ifndef CONFIG_AFTERBURN
 cmd_as_o_S       = $(CC) $(a_flags) -c -o $@ $<
+else
+cmd_as_o_S        = $(CC) $(a_flags) -c -E -o $(@D)/.preburn_$(@F:.o=.s) $< 
+cmd_as_o_S       += && afterburner $(@D)/.preburn_$(@F:.o=.s) > $(@D)/.afterburnt_$(@F:.o=.s)
+cmd_as_o_S       += && $(CC) $(filter-out -g,$(a_flags)) -c -o $@ $(@D)/.afterburnt_$(@F:.o=.s)
+endif
 
 %.o: %.S FORCE
 	$(call if_changed_dep,as_o_S)
@@ -209,6 +223,14 @@
 targets += $(real-objs-y) $(real-objs-m) $(lib-y)
 targets += $(extra-y) $(MAKECMDGOALS) $(always)
 
+# Linker scripts preprocessor (.lds.S -> .lds)
+# ---------------------------------------------------------------------------
+quiet_cmd_cpp_lds_S = LDS     $@
+	cmd_cpp_lds_S = $(CPP) $(cpp_flags) -D__ASSEMBLY__ -o $@ $<
+
+%.lds: %.lds.S FORCE
+	$(call if_changed_dep,cpp_lds_S)
+
 # Build the compiled-in targets
 # ---------------------------------------------------------------------------
 
diff -Naur linux-2.6.8.1.pristine/scripts/Makefile.lib linux-2.6.8.1/scripts/Makefile.lib
--- linux-2.6.8.1.pristine/scripts/Makefile.lib	2004-08-14 10:55:32.000000000 +0000
+++ linux-2.6.8.1/scripts/Makefile.lib	2006-08-17 15:53:18.000000000 +0000
@@ -139,6 +139,7 @@
 
 _c_flags       = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(*F).o)
 _a_flags       = $(AFLAGS) $(EXTRA_AFLAGS) $(AFLAGS_$(*F).o)
+_cpp_flags     = $(CPPFLAGS) $(EXTRA_CPPFLAGS) $(CPPFLAGS_$(@F))
 _hostc_flags   = $(HOSTCFLAGS)   $(HOST_EXTRACFLAGS)   $(HOSTCFLAGS_$(*F).o)
 _hostcxx_flags = $(HOSTCXXFLAGS) $(HOST_EXTRACXXFLAGS) $(HOSTCXXFLAGS_$(*F).o)
 
@@ -149,6 +150,7 @@
 ifeq ($(KBUILD_SRC),)
 __c_flags	= $(_c_flags)
 __a_flags	= $(_a_flags)
+__cpp_flags     = $(_cpp_flags)
 __hostc_flags	= $(_hostc_flags)
 __hostcxx_flags	= $(_hostcxx_flags)
 else
@@ -164,6 +166,7 @@
 # FIXME: Replace both with specific CFLAGS* statements in the makefiles
 __c_flags	= $(call addtree,-I$(obj)) $(call flags,_c_flags)
 __a_flags	=                          $(call flags,_a_flags)
+__cpp_flags     =                          $(call flags,_cpp_flags)
 __hostc_flags	= -I$(obj)                 $(call flags,_hostc_flags)
 __hostcxx_flags	= -I$(obj)                 $(call flags,_hostcxx_flags)
 endif
@@ -175,6 +178,8 @@
 a_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(CPPFLAGS) \
 		 $(__a_flags) $(modkern_aflags)
 
+cpp_flags      = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(__cpp_flags)
+
 hostc_flags    = -Wp,-MD,$(depfile) $(__hostc_flags)
 hostcxx_flags  = -Wp,-MD,$(depfile) $(__hostcxx_flags)
 
