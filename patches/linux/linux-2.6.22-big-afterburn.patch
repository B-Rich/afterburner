diff -Naur linux-2.6.22.pristine/afterburn/afterburn.c linux-2.6.22-apic/afterburn/afterburn.c
--- linux-2.6.22.pristine/afterburn/afterburn.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-apic/afterburn/afterburn.c	2007-08-03 16:34:11.000000000 +0200
@@ -0,0 +1,160 @@
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <asm/current.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+#include "afterburn.h"
+// Exports to the afterburn wedge.
+
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+void * afterburn_thread_get_handle( void )
+{
+    return current->afterburn_handle;
+}
+
+void afterburn_thread_assign_handle( void * handle )
+{
+    current->afterburn_handle = handle;
+}
+
+
+// Imports from the afterburn wedge.  If these hooks are in the bss,
+// Linux will zero them after the wedge has hooked them.
+
+void afterburn_exit_thread( void *handle )
+{
+    // Dummy
+}
+
+int afterburn_signal_thread( void *handle )
+{
+    // Dummy
+    return 0;
+}
+
+SECTION(".data") REGPARM(3) void (*afterburn_exit_hook)( void *handle ) = afterburn_exit_thread;
+SECTION(".data") REGPARM(3) int (*afterburn_signal_hook)( void *handle ) = afterburn_signal_thread;
+#endif	/* CONFIG_AFTERBURN_THREAD_HOOKS */
+
+
+unsigned int afterburn_cpu_get_startup_ip( unsigned int apic_id  )
+{
+#if defined CONFIG_SMP
+	extern unsigned char startup_32_smp[];	
+	return (unsigned int) startup_32_smp;
+#else
+	return 0;
+#endif
+}
+
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+SECTION(".data")int (*afterburn_rewrite_module_hook)( unsigned long ) = NULL;
+#endif
+
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+SECTION(".data") REGPARM(3) void (*afterburn_sync_esp0)(void) = NULL;
+#endif
+
+SECTION("__ex_table") struct exception_table_entry 
+  afterburn_uaccess_fault_handler = {
+      (long)&afterburn_uaccess_fault_handler, 
+      (long)&afterburn_uaccess_fault_handler
+  };
+
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_get_user_hook)(void *to, const void *from, unsigned long n)  = NULL;
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_put_user_hook)(void *to, const void *from, unsigned long n) = NULL;
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_copy_from_user_hook)(void *to, const void *from, unsigned long n)  = NULL;
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_copy_to_user_hook)(void *to, const void *from, unsigned long n) = NULL;
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_clear_user_hook)(void *to, unsigned long n) = NULL;
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_strnlen_user_hook)(const char *s, unsigned long n) = NULL;
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_strncpy_from_user_hook)(char *dst, const char *src, unsigned long n, unsigned long *success) = NULL;
+#endif
+
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_dma_coherent_check)(unsigned long phys, unsigned long size);
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+#endif
+SECTION(".data") REGPARM(3) unsigned long (*afterburn_free_pgd_hook)(unsigned long pgd);
+
+#define EXPORT_THREAD_GET_HANDLE	0
+#define EXPORT_THREAD_SET_HANDLE	1
+#define EXPORT_UACCESS_FAULT_DATA	2
+#define EXPORT_BURN_PROF_COUNTERS_START	3
+#define EXPORT_BURN_PROF_COUNTERS_END	4
+#define EXPORT_CPU_GET_STARTUP_IP       5
+
+
+#define IMPORT_EXIT_HOOK		0
+#define IMPORT_SET_PTE_HOOK		1
+#define IMPORT_GET_USER_HOOK		2
+#define IMPORT_PUT_USER_HOOK		3
+#define IMPORT_COPY_FROM_USER_HOOK	4
+#define IMPORT_COPY_TO_USER_HOOK	5
+#define IMPORT_CLEAR_USER_HOOK		6
+#define IMPORT_STRNLEN_USER_HOOK	7
+#define IMPORT_STRNCPY_FROM_USER_HOOK	8
+#define IMPORT_READ_PTE_HOOK		9
+#define IMPORT_PTE_TEST_AND_CLEAR_HOOK	10
+#define IMPORT_PTE_GET_AND_CLEAR_HOOK	11
+#define IMPORT_PHYS_TO_DMA_HOOK		12
+#define IMPORT_DMA_TO_PHYS_HOOK		13
+#define IMPORT_FREE_PGD_HOOK		14
+#define IMPORT_REWRITE_MODULE_HOOK	15
+#define IMPORT_SIGNAL_HOOK		16
+#define IMPORT_ESP0_SYNC		17
+#define IMPORT_DMA_COHERENT_CHECK       18
+#define IMPORT_EXIT_PGD			19
+
+// These macros install the info into an unallocated ELF section.
+#define AFTERBURN_EXPORT( id, func ) \
+    asm ( ".pushsection .afterburn.exports;" \
+	    ".long " MKSTR(id) ";" \
+	    ".long " MKSTR(func) ";" \
+	    ".popsection;" )
+#define AFTERBURN_IMPORT( id, ptr ) \
+    EXPORT_SYMBOL( ptr ); \
+    asm ( ".pushsection .afterburn.imports;" \
+	    ".long " MKSTR(id) ";" \
+	    ".long " MKSTR(ptr) ";" \
+	    ".popsection;" )
+
+#define MKSTR(sym)	MKSTR2(sym)
+#define MKSTR2(sym)	#sym
+
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+AFTERBURN_EXPORT( EXPORT_THREAD_GET_HANDLE, afterburn_thread_get_handle );
+AFTERBURN_EXPORT( EXPORT_THREAD_SET_HANDLE, afterburn_thread_assign_handle );
+AFTERBURN_IMPORT( IMPORT_EXIT_HOOK, afterburn_exit_hook );
+AFTERBURN_IMPORT( IMPORT_SIGNAL_HOOK, afterburn_signal_hook );
+#endif
+AFTERBURN_EXPORT( EXPORT_UACCESS_FAULT_DATA, afterburn_uaccess_fault_handler );
+AFTERBURN_EXPORT( EXPORT_BURN_PROF_COUNTERS_START, __burn_prof_counters_start );
+AFTERBURN_EXPORT( EXPORT_BURN_PROF_COUNTERS_END, __burn_prof_counters_end );
+AFTERBURN_EXPORT( EXPORT_CPU_GET_STARTUP_IP, afterburn_cpu_get_startup_ip );
+
+
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+AFTERBURN_IMPORT( IMPORT_GET_USER_HOOK, afterburn_get_user_hook );
+AFTERBURN_IMPORT( IMPORT_COPY_FROM_USER_HOOK, afterburn_copy_from_user_hook );
+AFTERBURN_IMPORT( IMPORT_PUT_USER_HOOK, afterburn_put_user_hook );
+AFTERBURN_IMPORT( IMPORT_COPY_TO_USER_HOOK, afterburn_copy_to_user_hook );
+AFTERBURN_IMPORT( IMPORT_CLEAR_USER_HOOK, afterburn_clear_user_hook );
+AFTERBURN_IMPORT( IMPORT_STRNLEN_USER_HOOK, afterburn_strnlen_user_hook );
+AFTERBURN_IMPORT( IMPORT_STRNCPY_FROM_USER_HOOK, afterburn_strncpy_from_user_hook );
+#endif
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+AFTERBURN_IMPORT( IMPORT_DMA_COHERENT_CHECK, afterburn_dma_coherent_check );
+AFTERBURN_IMPORT( IMPORT_PHYS_TO_DMA_HOOK, afterburn_phys_to_dma_hook );
+AFTERBURN_IMPORT( IMPORT_DMA_TO_PHYS_HOOK, afterburn_dma_to_phys_hook );
+AFTERBURN_IMPORT( IMPORT_FREE_PGD_HOOK, afterburn_free_pgd_hook );
+#endif
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+AFTERBURN_IMPORT( IMPORT_REWRITE_MODULE_HOOK, afterburn_rewrite_module_hook );
+#endif
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+AFTERBURN_IMPORT( IMPORT_ESP0_SYNC, afterburn_sync_esp0 );
+#endif
+
diff -Naur linux-2.6.22.pristine/afterburn/afterburn.h linux-2.6.22-apic/afterburn/afterburn.h
--- linux-2.6.22.pristine/afterburn/afterburn.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-apic/afterburn/afterburn.h	2007-08-03 16:34:11.000000000 +0200
@@ -0,0 +1,79 @@
+#ifndef __AFTERBURN__AFTERBURN_H__
+#define __AFTERBURN__AFTERBURN_H__
+
+#define SECTION(x) __attribute__((section(x)))
+#define REGPARM(x) __attribute__((regparm(x)))
+
+// Exports to the afterburn wedge.
+
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+extern void * afterburn_thread_get_handle( void );
+extern void afterburn_thread_assign_handle( void * handle );
+// Imports from the afterburn wedge.  If these hooks are in the bss,
+// Linux will zero them after the wedge has hooked them.
+extern void afterburn_exit_thread( void *handle );
+extern int afterburn_signal_thread( void *handle );
+extern SECTION(".data") REGPARM(3) void (*afterburn_exit_hook)( void *handle );
+extern SECTION(".data") REGPARM(3) int (*afterburn_signal_hook)( void *handle );
+#endif	/* CONFIG_AFTERBURN_THREAD_HOOKS */
+
+extern unsigned int afterburn_cpu_get_startup_ip( unsigned int apic_id  );
+
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+extern SECTION(".data")int (*afterburn_rewrite_module_hook)( unsigned long );
+#endif
+
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+extern SECTION(".data") REGPARM(3) void (*afterburn_sync_esp0)(void);
+#endif
+
+extern SECTION("__ex_table") struct exception_table_entry afterburn_uaccess_fault_handler;
+
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_get_user_hook)(void *to, const void *from, unsigned long n);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_put_user_hook)(void *to, const void *from, unsigned long n);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_copy_from_user_hook)(void *to, const void *from, unsigned long n) ;
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_copy_to_user_hook)(void *to, const void *from, unsigned long n);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_clear_user_hook)(void *to, unsigned long n);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_strnlen_user_hook)(const char *s, unsigned long n);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_strncpy_from_user_hook)(char *dst, const char *src, unsigned long n, unsigned long *success);
+#endif
+
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_dma_coherent_check)(unsigned long phys, unsigned long size);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_phys_to_dma_hook)(unsigned long phys, unsigned long size);
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_dma_to_phys_hook)(unsigned long dma);
+#endif
+extern SECTION(".data") REGPARM(3) unsigned long (*afterburn_free_pgd_hook)(unsigned long pgd);
+
+#define EXPORT_THREAD_GET_HANDLE	0
+#define EXPORT_THREAD_SET_HANDLE	1
+#define EXPORT_UACCESS_FAULT_DATA	2
+#define EXPORT_BURN_PROF_COUNTERS_START	3
+#define EXPORT_BURN_PROF_COUNTERS_END	4
+#define EXPORT_CPU_GET_STARTUP_IP       5
+
+
+#define IMPORT_EXIT_HOOK		0
+#define IMPORT_SET_PTE_HOOK		1
+#define IMPORT_GET_USER_HOOK		2
+#define IMPORT_PUT_USER_HOOK		3
+#define IMPORT_COPY_FROM_USER_HOOK	4
+#define IMPORT_COPY_TO_USER_HOOK	5
+#define IMPORT_CLEAR_USER_HOOK		6
+#define IMPORT_STRNLEN_USER_HOOK	7
+#define IMPORT_STRNCPY_FROM_USER_HOOK	8
+#define IMPORT_READ_PTE_HOOK		9
+#define IMPORT_PTE_TEST_AND_CLEAR_HOOK	10
+#define IMPORT_PTE_GET_AND_CLEAR_HOOK	11
+#define IMPORT_PHYS_TO_DMA_HOOK		12
+#define IMPORT_DMA_TO_PHYS_HOOK		13
+#define IMPORT_FREE_PGD_HOOK		14
+#define IMPORT_REWRITE_MODULE_HOOK	15
+#define IMPORT_SIGNAL_HOOK		16
+#define IMPORT_ESP0_SYNC		17
+#define IMPORT_DMA_COHERENT_CHECK       18
+#define IMPORT_EXIT_PGD			19
+
+
+#endif /* !__AFTERBURN__AFTERBURN_H__ */
diff -Naur linux-2.6.22.pristine/afterburn/annotate.h linux-2.6.22-apic/afterburn/annotate.h
--- linux-2.6.22.pristine/afterburn/annotate.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-apic/afterburn/annotate.h	2007-08-03 17:47:01.000000000 +0200
@@ -0,0 +1,443 @@
+#ifndef __AFTERBURN__ANNOTATE_H__
+#define __AFTERBURN__ANNOTATE_H__
+
+#include <asm/bitops.h>
+
+
+static inline void 
+dp83820_write_annotate(unsigned int b, volatile void __iomem *addr)
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.dp83820\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(b), "m"(*(unsigned long *)addr) : "memory" );
+}
+
+static inline unsigned int 
+dp83820_read_annotate(const volatile void __iomem *addr)
+{
+    unsigned int temp;
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.dp83820\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(temp) : "m"(*(unsigned long *)addr) );
+    return temp;
+}
+
+#define pgd_read_annotate( pgd ) ({ \
+    unsigned long temp; \
+    __asm__ ( \
+	    "7777:" \
+	    "mov %1, %0\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "7778:" \
+	    ".pushsection .afterburn.pgd_read\n" \
+	    ".align 4\n" \
+	    ".long 7777b\n" \
+	    ".long 7778b\n" \
+	    ".popsection\n" \
+	    : "=r"(temp) : "m"(pgd) ); \
+    temp; })
+
+
+#define pte_read_annotate( pte ) ({ \
+    unsigned long temp; \
+    __asm__ ( \
+	    "7777:" \
+	    "mov %1, %0\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "nop\n" \
+	    "7778:" \
+	    ".pushsection .afterburn.pte_read\n" \
+	    ".align 4\n" \
+	    ".long 7777b\n" \
+	    ".long 7778b\n" \
+	    ".popsection\n" \
+	    : "=r"(temp) : "m"(pte) ); \
+    temp; })
+
+static inline void 
+pte_set_annotate(pte_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val), "m"(*addr) );
+}
+
+static inline void 
+pgd_set_annotate(pgd_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pgd_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val) );
+}
+
+static inline void 
+pmd_set_annotate(pmd_t *addr, unsigned long val )
+{
+    __asm__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pmd_set\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=m"(*addr) : "r"(val) );
+}
+
+static inline int pte_test_and_clear_bit_annotate( int bit, volatile pte_t *ptep )
+{
+    int oldbit;
+
+    __asm__ (
+	    "7777:"
+	    LOCK_PREFIX
+	    "btrl %2, %1\n"
+	    "sbbl %0, %0\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_test_clear\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=a"(oldbit), "=m"(*(volatile long *)ptep)
+	    : "0"(bit) );
+    return oldbit;
+}
+
+static inline pte_t
+pte_read_clear_annotate( pte_t *pteptr )
+{
+    pte_t x = {0};
+
+    __asm__ (
+	    "7777:"
+	    "xchgl %0, %1\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.pte_read\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(x) 
+	    : "m"(*(volatile unsigned long *)pteptr), "0"(x)
+	    : "memory" );
+
+    return x;
+}
+
+
+static inline void 
+ioapic_write_annotate(unsigned int val, volatile void __iomem *addr )
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.ioapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(val), "m"(*(unsigned long *)addr) : "memory" );
+}
+
+static inline unsigned int 
+ioapic_read_annotate(volatile void __iomem *addr )
+{
+    unsigned int temp;
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.ioapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(temp) : "m"(*(unsigned long *)addr) );
+    return temp;
+}
+
+
+static inline void 
+lapic_write_annotate(unsigned long reg, unsigned long v )
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.lapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(v), "m"(*(unsigned long *)reg) : "memory" );
+}
+
+static inline void 
+lapic_xchg_annotate(unsigned long reg, unsigned long v)
+{
+    __asm__ __volatile__ (
+	    "7777:"
+	    "xchgl %0, %1\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.lapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : : "r"(v), "m"(*(unsigned long *)reg) : "memory" );
+}
+
+
+static inline unsigned int 
+lapic_read_annotate(const volatile void __iomem *addr)
+{
+    unsigned int temp;
+    __asm__ __volatile__ (
+	    "7777:"
+	    "mov %1, %0\n" 
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "nop\n"
+	    "7778:"
+	    ".pushsection .afterburn.lapic\n"
+	    ".align 4\n"
+	    ".long 7777b\n"
+	    ".long 7778b\n"
+	    ".popsection\n"
+	    : "=r"(temp) : "m"(*(unsigned long *)addr) );
+    return temp;
+}
+
+
+
+
+
+#endif /* __AFTERBURN__ANNOTATE_H__ */
diff -Naur linux-2.6.22.pristine/afterburn/Kconfig linux-2.6.22-apic/afterburn/Kconfig
--- linux-2.6.22.pristine/afterburn/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-apic/afterburn/Kconfig	2007-08-03 16:34:11.000000000 +0200
@@ -0,0 +1,112 @@
+menu "Afterburn"
+
+config AFTERBURN
+	bool "Afterburn pre-virtualization"
+	help
+	  Support for running Linux as a virtual machine in a hypervisor
+	  environment.
+
+#config AFTERBURN_STATIC
+#	depends on AFTERBURN
+#	bool "Staticly link against wedge"
+#	default y
+#	help
+#          Instruction afterburning is normally staticaly linked at build time
+#          and you limit yourself to the particular wedge. Use this option to instead
+#          generate dynamic patchup symbols instead.
+
+config AFTERBURN_L4KA
+	depends on AFTERBURN
+	bool "Support the L4Ka::Pistachio environment?"
+	default y
+	select AFTERBURN_RELINK
+	select AFTERBURN_HOOK_UACCESS
+	select AFTERBURN_ANNOTATIONS
+	select AFTERBURN_THREAD_HOOKS
+	select AFTERBURN_MODULE_HOOKS
+
+config AFTERBURN_XEN
+	depends on AFTERBURN
+	bool "Support the Xen environment?"
+	default y
+	select AFTERBURN_RELINK
+	select AFTERBURN_ANNOTATIONS
+	select AFTERBURN_XEN_HOOKS
+	select AFTERBURN_MODULE_HOOKS
+
+config AFTERBURN_DEVICE_PASSTHRU
+	depends on AFTERBURN
+	bool "Permit pass through device access?"
+	default y
+	select AFTERBURN_HOOK_DMA
+
+config AFTERBURN_KERNEL_PROFILING
+	depends on AFTERBURN
+	bool "Profile the kernel? (Requires frame pointers)"
+	select DEBUG_KERNEL
+	select FRAME_POINTER
+
+menu "Advanced"
+depends on AFTERBURN
+
+config AFTERBURN_RELINK
+	depends on AFTERBURN
+	bool "Relink the Linux kernel at a new address?"
+	default y
+
+config AFTERBURN_LINK_BASE
+	depends on AFTERBURN && AFTERBURN_RELINK
+	hex "The kernel link address"
+	default "0x80000000"
+	help
+	  This address is the first byte location of where the kernel's
+	  available virtual address space starts.
+
+config AFTERBURN_VADDR_END
+	depends on AFTERBURN && AFTERBURN_RELINK
+	hex "The end of the kernel's virtual address space"
+	default "0xbc000000"
+	help
+	  This address is the first byte location of where *unavailable*
+	  memory starts.  It is thus the end of the kernel's available
+	  virtual address space.  If you use a dynamic wedge, consider
+	  leaving enough room for the wedge to link itself at the
+	  end of the kernel's available virtual address space.
+
+config AFTERBURN_USER_VADDR_END
+	depends on AFTERBURN && AFTERBURN_RELINK
+	hex "The end of a user application's virtual address space"
+	default "0x80000000"
+	help
+	  This address marks the end of the user address space managed
+	  by Linux.  All addresses starting here and beyond are managed 
+	  by the hypervisor.
+
+config AFTERBURN_HOOK_UACCESS
+	depends on AFTERBURN
+	bool "Permit the virtual machine to hook user data access?"
+
+config AFTERBURN_HOOK_DMA
+	depends on AFTERBURN
+	bool "Permit the virtual machine to hook DMA translation?"
+
+config AFTERBURN_XEN_HOOKS
+	depends on AFTERBURN
+	bool "Extra afterburn hooks required for Xen"
+
+config AFTERBURN_ANNOTATIONS
+	depends on AFTERBURN
+	bool "Generate Afterburn annotations and NOPs for optimizations"
+
+config AFTERBURN_THREAD_HOOKS
+	depends on AFTERBURN
+	bool "Permit the virtual machine to hook high-level thread operations?"
+
+config AFTERBURN_MODULE_HOOKS
+	depends on AFTERBURN
+	bool "Support dynamic kernel module loading?"
+	default y
+
+endmenu
+endmenu
+
diff -Naur linux-2.6.22.pristine/afterburn/Makefile linux-2.6.22-apic/afterburn/Makefile
--- linux-2.6.22.pristine/afterburn/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-apic/afterburn/Makefile	2007-08-03 16:34:11.000000000 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_AFTERBURN) += afterburn.o
diff -Naur linux-2.6.22.pristine/afterburn/modpost.h linux-2.6.22-apic/afterburn/modpost.h
--- linux-2.6.22.pristine/afterburn/modpost.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-apic/afterburn/modpost.h	2007-08-03 16:34:11.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef __AFTERBURN__MODPOST_H__
+#define __AFTERBURN__MODPOST_H__
+
+/* 
+ * Include all afterburner-special sections here
+ */
+const char *afterburn_section_ref_ok[] = {
+	".afterburn",				
+	".afterburn.imports",
+	".afterburn.exports",
+	".afterburn.dp83820",			
+	".afterburn.pgd_read",			
+	".afterburn.pgd_set",			
+	".afterburn.pte_set",			
+	".afterburn.pte_read",			
+	".afterburn.pte_test_clear",		
+	".pushsection .afterburn.pmd"		
+	".afterburn.lapic",			
+	".afterburn.ioapic",
+	NULL
+};
+
+#endif /*__AFTERBURN__MODPOST_H__ */
diff -Naur linux-2.6.22.pristine/arch/i386/boot/compressed/Makefile linux-2.6.22-apic/arch/i386/boot/compressed/Makefile
--- linux-2.6.22.pristine/arch/i386/boot/compressed/Makefile	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/boot/compressed/Makefile	2007-08-03 16:34:11.000000000 +0200
@@ -9,7 +9,7 @@
 EXTRA_AFLAGS	:= -traditional
 
 LDFLAGS_vmlinux := -T
-CFLAGS_misc.o += -fPIC
+#CFLAGS_misc.o += -fPIC
 hostprogs-y	:= relocs
 
 $(obj)/vmlinux: $(src)/vmlinux.lds $(obj)/head.o $(obj)/misc.o $(obj)/piggy.o FORCE
diff -Naur linux-2.6.22.pristine/arch/i386/Kconfig linux-2.6.22-apic/arch/i386/Kconfig
--- linux-2.6.22.pristine/arch/i386/Kconfig	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/Kconfig	2007-08-03 16:34:11.000000000 +0200
@@ -3,7 +3,9 @@
 # see Documentation/kbuild/kconfig-language.txt.
 #
 
-mainmenu "Linux Kernel Configuration"
+mainmenu "Linux Kernel Configuration
+
+"source "afterburn/Kconfig"
 
 config X86_32
 	bool
@@ -89,6 +91,7 @@
 
 source "init/Kconfig"
 
+
 menu "Processor type and features"
 
 source "kernel/time/Kconfig"
@@ -814,7 +817,7 @@
 	  For more details see Documentation/kdump/kdump.txt
 
 config PHYSICAL_START
-	hex "Physical address where the kernel is loaded" if (EMBEDDED || CRASH_DUMP)
+	hex "Physical address where the kernel is loaded" if (EMBEDDED || CRASH_DUMP || AFTERBURN)
 	default "0x100000"
 	help
 	  This gives the physical address where the kernel is loaded.
@@ -1275,3 +1278,4 @@
 config KTIME_SCALAR
 	bool
 	default y
+
diff -Naur linux-2.6.22.pristine/arch/i386/kernel/head.S linux-2.6.22-apic/arch/i386/kernel/head.S
--- linux-2.6.22.pristine/arch/i386/kernel/head.S	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/kernel/head.S	2007-08-03 16:34:11.000000000 +0200
@@ -401,20 +401,40 @@
 	dec %ecx
 	jne rp_sidt
 
-.macro	set_early_handler handler,trapno
-	lea \handler,%edx
+	lea early_divide_err,%edx
 	movl $(__KERNEL_CS << 16),%eax
 	movw %dx,%ax
 	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
 	lea idt_table,%edi
-	movl %eax,8*\trapno(%edi)
-	movl %edx,8*\trapno+4(%edi)
-.endm
-
-	set_early_handler handler=early_divide_err,trapno=0
-	set_early_handler handler=early_illegal_opcode,trapno=6
-	set_early_handler handler=early_protection_fault,trapno=13
-	set_early_handler handler=early_page_fault,trapno=14
+	movl %eax,8*0(%edi)
+	movl %edx,8*0+4(%edi)
+
+	
+	lea early_illegal_opcode,%edx
+	movl $(__KERNEL_CS << 16),%eax
+	movw %dx,%ax
+	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
+	lea idt_table,%edi
+	movl %eax,8*6(%edi)
+	movl %edx,8*6+4(%edi)
+
+	
+	lea early_protection_fault,%edx
+	movl $(__KERNEL_CS << 16),%eax
+	movw %dx,%ax
+	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
+	lea idt_table,%edi
+	movl %eax,8*13(%edi)
+	movl %edx,8*13+4(%edi)
+
+	
+	lea early_page_fault,%edx
+	movl $(__KERNEL_CS << 16),%eax
+	movw %dx,%ax
+	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
+	lea idt_table,%edi
+	movl %eax,8*14(%edi)
+	movl %edx,8*14+4(%edi)
 
 	ret
 
diff -Naur linux-2.6.22.pristine/arch/i386/kernel/io_apic.c linux-2.6.22-apic/arch/i386/kernel/io_apic.c
--- linux-2.6.22.pristine/arch/i386/kernel/io_apic.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/kernel/io_apic.c	2007-08-03 17:35:25.000000000 +0200
@@ -98,6 +98,16 @@
 	unsigned int data;
 };
 
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../../afterburn/annotate.h"
+#define __io_apic_read			ioapic_read_annotate
+#define __io_apic_write			ioapic_write_annotate
+#else
+#define __io_apic_read			readl
+#define __io_apic_write			writel
+
+#endif
+
 static __attribute_const__ struct io_apic __iomem *io_apic_base(int idx)
 {
 	return (void __iomem *) __fix_to_virt(FIX_IO_APIC_BASE_0 + idx)
@@ -107,17 +117,16 @@
 static inline unsigned int io_apic_read(unsigned int apic, unsigned int reg)
 {
 	struct io_apic __iomem *io_apic = io_apic_base(apic);
-	writel(reg, &io_apic->index);
-	return readl(&io_apic->data);
+	__io_apic_write(reg, &io_apic->index);
+	return __io_apic_read(&io_apic->data);
 }
 
 static inline void io_apic_write(unsigned int apic, unsigned int reg, unsigned int value)
 {
 	struct io_apic __iomem *io_apic = io_apic_base(apic);
-	writel(reg, &io_apic->index);
-	writel(value, &io_apic->data);
+	__io_apic_write(reg, &io_apic->index);
+	__io_apic_write(value, &io_apic->data);
 }
-
 /*
  * Re-write a value: to be used for read-modify-write
  * cycles where the read already set up the index register.
@@ -128,8 +137,8 @@
 {
 	volatile struct io_apic __iomem *io_apic = io_apic_base(apic);
 	if (sis_apic_bug)
-		writel(reg, &io_apic->index);
-	writel(value, &io_apic->data);
+		__io_apic_write(reg, &io_apic->index);
+	__io_apic_write(value, &io_apic->data);
 }
 
 union entry_union {
@@ -1910,8 +1919,11 @@
 
 	local_irq_enable();
 	/* Let ten ticks pass... */
-	mdelay((10 * 1000) / HZ);
-
+#if defined(CONFIG_AFTERBURN)
+	mdelay((50 * 1000) / HZ);
+#else
+ 	mdelay((10 * 1000) / HZ);
+#endif	
 	/*
 	 * Expect a few ticks at least, to be sure some possible
 	 * glue logic does not lock up after one or two first
diff -Naur linux-2.6.22.pristine/arch/i386/kernel/pci-dma.c linux-2.6.22-apic/arch/i386/kernel/pci-dma.c
--- linux-2.6.22.pristine/arch/i386/kernel/pci-dma.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/kernel/pci-dma.c	2007-08-03 16:34:11.000000000 +0200
@@ -23,6 +23,11 @@
 	unsigned long	*bitmap;
 };
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+#include "../../../afterburn/afterburn.h"
+#endif
+
+
 void *dma_alloc_coherent(struct device *dev, size_t size,
 			   dma_addr_t *dma_handle, gfp_t gfp)
 {
@@ -52,7 +57,13 @@
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+		if (afterburn_phys_to_dma_hook)
+		*dma_handle = afterburn_phys_to_dma_hook(virt_to_phys(ret), size);
+		else
+#endif
 		*dma_handle = virt_to_phys(ret);
+		
 	}
 	return ret;
 }
diff -Naur linux-2.6.22.pristine/arch/i386/kernel/signal.c linux-2.6.22-apic/arch/i386/kernel/signal.c
--- linux-2.6.22.pristine/arch/i386/kernel/signal.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/kernel/signal.c	2007-08-03 16:34:11.000000000 +0200
@@ -566,6 +566,9 @@
  * want to handle. Thus you cannot kill init even with a SIGKILL even by
  * mistake.
  */
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+#include "../../../afterburn/afterburn.h"
+#endif
 static void fastcall do_signal(struct pt_regs *regs)
 {
 	siginfo_t info;
@@ -573,6 +576,13 @@
 	struct k_sigaction ka;
 	sigset_t *oldset;
 
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+	{
+	    if( afterburn_signal_hook &&
+		    afterburn_signal_hook(current->afterburn_handle) )
+		return;
+	}
+#endif
 	/*
 	 * We want the common case to go fast, which
 	 * is why we may in certain cases get here from
diff -Naur linux-2.6.22.pristine/arch/i386/kernel/vmlinux.lds.S linux-2.6.22-apic/arch/i386/kernel/vmlinux.lds.S
--- linux-2.6.22.pristine/arch/i386/kernel/vmlinux.lds.S	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/kernel/vmlinux.lds.S	2007-08-03 16:34:11.000000000 +0200
@@ -14,8 +14,12 @@
  * change if kernel is relocated, make the symbol section relative and
  * put it inside the section definition.
  */
+#if defined(CONFIG_AFTERBURN)
+#define LOAD_OFFSET 0
+#else
 #define LOAD_OFFSET __PAGE_OFFSET
-
+#endif
+	
 #include <asm-generic/vmlinux.lds.h>
 #include <asm/thread_info.h>
 #include <asm/page.h>
@@ -78,6 +82,11 @@
 	CONSTRUCTORS
 	} :data
 
+  __burn_prof_counters_start = .;
+  .burn_prof_counters : { *(.burn_prof_counters) }
+  __burn_prof_counters_end = .;
+
+
   . = ALIGN(4096);
   .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) {
   	__nosave_begin = .;
diff -Naur linux-2.6.22.pristine/arch/i386/lib/usercopy.c linux-2.6.22-apic/arch/i386/lib/usercopy.c
--- linux-2.6.22.pristine/arch/i386/lib/usercopy.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/lib/usercopy.c	2007-08-03 16:34:11.000000000 +0200
@@ -14,6 +14,11 @@
 #include <asm/uaccess.h>
 #include <asm/mmx.h>
 
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+#include "../../../afterburn/afterburn.h"
+#endif
+
+
 static inline int __movsl_is_ok(unsigned long a1, unsigned long a2, unsigned long n)
 {
 #ifdef CONFIG_X86_INTEL_USERCOPY
@@ -82,6 +87,15 @@
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	long res;
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_strncpy_from_user_hook ) {
+		unsigned long success;
+		res = afterburn_strncpy_from_user_hook( dst, src, count, &success );
+		if( !success )
+			return -EFAULT;
+		return res;
+	}
+#endif
 	__do_strncpy_from_user(dst, src, count, res);
 	return res;
 }
@@ -110,7 +124,19 @@
 {
 	long res = -EFAULT;
 	if (access_ok(VERIFY_READ, src, 1))
+	{
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	    if( afterburn_strncpy_from_user_hook ) {
+			unsigned long success;
+			res = afterburn_strncpy_from_user_hook( dst, src, count, &success );
+			if( !success )
+				return -EFAULT;
+			return res;
+		}
+#endif
+
 		__do_strncpy_from_user(dst, src, count, res);
+	}
 	return res;
 }
 EXPORT_SYMBOL(strncpy_from_user);
@@ -154,6 +180,10 @@
 unsigned long
 clear_user(void __user *to, unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_clear_user_hook )
+		return n - afterburn_clear_user_hook( to, n );
+#endif
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, to, n))
 		__do_clear_user(to, n);
@@ -175,6 +205,10 @@
 unsigned long
 __clear_user(void __user *to, unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_clear_user_hook )
+		return n - afterburn_clear_user_hook( to, n );
+#endif
 	__do_clear_user(to, n);
 	return n;
 }
@@ -196,6 +230,11 @@
 	unsigned long mask = -__addr_ok(s);
 	unsigned long res, tmp;
 
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_strnlen_user_hook )
+		return afterburn_strnlen_user_hook( s, n );
+#endif
+
 	might_sleep();
 
 	__asm__ __volatile__(
@@ -716,6 +755,11 @@
 unsigned long __copy_to_user_ll(void __user *to, const void *from,
 				unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_copy_to_user_hook )
+		return n - afterburn_copy_to_user_hook( to, from, n );
+#endif
+
 #ifndef CONFIG_X86_WP_WORKS_OK
 	if (unlikely(boot_cpu_data.wp_works_ok == 0) &&
 			((unsigned long )to) < TASK_SIZE) {
@@ -784,6 +828,10 @@
 unsigned long __copy_from_user_ll(void *to, const void __user *from,
 					unsigned long n)
 {
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+	if( afterburn_copy_from_user_hook )
+		return n - afterburn_copy_from_user_hook( to, from, n );
+#endif
 	if (movsl_is_ok(to, from, n))
 		__copy_user_zeroing(to, from, n);
 	else
diff -Naur linux-2.6.22.pristine/arch/i386/mm/init.c linux-2.6.22-apic/arch/i386/mm/init.c
--- linux-2.6.22.pristine/arch/i386/mm/init.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/mm/init.c	2007-08-03 16:34:11.000000000 +0200
@@ -374,8 +374,13 @@
 	 * All user-space mappings are explicitly cleared after
 	 * SMP startup.
 	 */
+#if defined(CONFIG_AFTERBURN)
+	pgd_base[0] = pgd_base[USER_PGD_PTRS];
+#else
 	set_pgd(&base[0], base[USER_PTRS_PER_PGD]);
 #endif
+
+#endif
 }
 
 /*
@@ -424,9 +429,14 @@
 	 * created - mappings will be set by set_fixmap():
 	 */
 	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
+#if defined(CONFIG_AFTERBURN)
+	//page_table_range_init(vaddr, vaddr + PMD_SIZE, pgd_base);
 	end = (FIXADDR_TOP + PMD_SIZE - 1) & PMD_MASK;
 	page_table_range_init(vaddr, end, pgd_base);
-
+#else
+	end = (FIXADDR_TOP + PMD_SIZE - 1) & PMD_MASK;
+	page_table_range_init(vaddr, end, pgd_base);
+#endif
 	permanent_kmaps_init(pgd_base);
 
 	paravirt_pagetable_setup_done(pgd_base);
@@ -462,11 +472,15 @@
 	 * Note that "pgd_clear()" doesn't do it for
 	 * us, because pgd_clear() is a no-op on i386.
 	 */
+#if defined(CONFIG_AFTERBURN)
+	for (i = 0; i < USER_PGD_PTRS; i++)
+#else
 	for (i = 0; i < USER_PTRS_PER_PGD; i++)
+#endif
 #ifdef CONFIG_X86_PAE
-		set_pgd(swapper_pg_dir+i, __pgd(1 + __pa(empty_zero_page)));
+       	    set_pgd(swapper_pg_dir+i, __pgd(1 + __pa(empty_zero_page)));
 #else
-		set_pgd(swapper_pg_dir+i, __pgd(0));
+	    set_pgd(swapper_pg_dir+i, __pgd(0));
 #endif
 	flush_tlb_all();
 }
diff -Naur linux-2.6.22.pristine/arch/i386/mm/pgtable.c linux-2.6.22-apic/arch/i386/mm/pgtable.c
--- linux-2.6.22.pristine/arch/i386/mm/pgtable.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/arch/i386/mm/pgtable.c	2007-08-03 16:34:11.000000000 +0200
@@ -145,7 +145,13 @@
 }
 
 static int fixmaps;
+
+#if defined(CONFIG_AFTERBURN_RELINK)
+unsigned long __FIXADDR_TOP = ((unsigned long)CONFIG_AFTERBURN_VADDR_END-0x1000);
+#else
 unsigned long __FIXADDR_TOP = 0xfffff000;
+#endif
+
 EXPORT_SYMBOL(__FIXADDR_TOP);
 
 void __set_fixmap (enum fixed_addresses idx, unsigned long phys, pgprot_t flags)
diff -Naur linux-2.6.22.pristine/drivers/net/ns83820.c linux-2.6.22-apic/drivers/net/ns83820.c
--- linux-2.6.22.pristine/drivers/net/ns83820.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/drivers/net/ns83820.c	2007-08-03 16:34:11.000000000 +0200
@@ -120,6 +120,13 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define readl dp83820_read_annotate
+#define writel dp83820_write_annotate
+#endif
+
+
 #define DRV_NAME "ns83820"
 
 /* Global parameters.  See module_param near the bottom. */
diff -Naur linux-2.6.22.pristine/include/asm-i386/apic.h linux-2.6.22-apic/include/asm-i386/apic.h
--- linux-2.6.22.pristine/include/asm-i386/apic.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/apic.h	2007-08-03 16:34:11.000000000 +0200
@@ -33,12 +33,21 @@
 
 extern void generic_apic_probe(void);
 
+
 #ifdef CONFIG_X86_LOCAL_APIC
 
 /*
  * Basic functions accessing APICs.
  */
-#ifdef CONFIG_PARAVIRT
+
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define apic_read(reg)			lapic_read_annotate((APIC_BASE+reg))
+#define apic_write(reg, v)		lapic_write_annotate((APIC_BASE+reg), v)
+#define apic_write_atomic(reg, v)	lapic_xchg_annotate((APIC_BASE+reg), v)
+#define setup_boot_clock()		
+#define setup_secondary_clock()	       
+#elif defined(CONFIG_PARAVIRT)
 #include <asm/paravirt.h>
 #else
 #define apic_write native_apic_write
diff -Naur linux-2.6.22.pristine/include/asm-i386/dma-mapping.h linux-2.6.22-apic/include/asm-i386/dma-mapping.h
--- linux-2.6.22.pristine/include/asm-i386/dma-mapping.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/dma-mapping.h	2007-08-03 16:34:11.000000000 +0200
@@ -8,6 +8,10 @@
 #include <asm/scatterlist.h>
 #include <asm/bug.h>
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+#include "../../../afterburn/afterburn.h"
+#endif
+
 #define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 #define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 
@@ -24,6 +28,10 @@
 	BUG_ON(!valid_dma_direction(direction));
 	WARN_ON(size == 0);
 	flush_write_buffers();
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(virt_to_phys(ptr), size);
+#endif
 	return virt_to_phys(ptr);
 }
 
@@ -46,6 +54,11 @@
 	for (i = 0; i < nents; i++ ) {
 		BUG_ON(!sg[i].page);
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+		if (afterburn_phys_to_dma_hook)
+			sg[i].dma_address = afterburn_phys_to_dma_hook(page_to_phys(sg[i].page), sg[i].length) + sg[i].offset;
+		else
+#endif
 		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
 	}
 
@@ -58,6 +71,11 @@
 	     size_t size, enum dma_data_direction direction)
 {
 	BUG_ON(!valid_dma_direction(direction));
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(page_to_phys(page), PAGE_SIZE) + offset;
+#endif
+
 	return page_to_phys(page) + offset;
 }
 
diff -Naur linux-2.6.22.pristine/include/asm-i386/dwarf2.h linux-2.6.22-apic/include/asm-i386/dwarf2.h
--- linux-2.6.22.pristine/include/asm-i386/dwarf2.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/dwarf2.h	2007-08-03 16:34:11.000000000 +0200
@@ -38,7 +38,7 @@
 
 /* Due to the structure of pre-exisiting code, don't use assembler line
    comment character # to ignore the arguments. Instead, use a dummy macro. */
-.macro ignore a=0, b=0, c=0, d=0
+.macro ignore a, b, c, d
 .endm
 
 #define CFI_STARTPROC	ignore
diff -Naur linux-2.6.22.pristine/include/asm-i386/fixmap.h linux-2.6.22-apic/include/asm-i386/fixmap.h
--- linux-2.6.22.pristine/include/asm-i386/fixmap.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/fixmap.h	2007-08-03 16:34:11.000000000 +0200
@@ -20,6 +20,7 @@
  * the start of the fixmap.
  */
 extern unsigned long __FIXADDR_TOP;
+
 #define FIXADDR_USER_START     __fix_to_virt(FIX_VDSO)
 #define FIXADDR_USER_END       __fix_to_virt(FIX_VDSO - 1)
 
diff -Naur linux-2.6.22.pristine/include/asm-i386/io.h linux-2.6.22-apic/include/asm-i386/io.h
--- linux-2.6.22.pristine/include/asm-i386/io.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/io.h	2007-08-03 16:34:11.000000000 +0200
@@ -44,6 +44,12 @@
 
 #ifdef __KERNEL__
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+#include "../../../afterburn/afterburn.h"
+#include <linux/mm.h>
+#endif
+
+
 #include <asm-generic/iomap.h>
 
 #include <linux/vmalloc.h>
@@ -135,9 +141,41 @@
 #define dmi_iounmap bt_iounmap
 #define dmi_alloc alloc_bootmem
 
+#if defined(CONFIG_AFTERBURN_HOOK_DMA)
+static inline unsigned long virt_to_bus( void * virt )
+{
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(virt_to_phys(virt),PAGE_SIZE);
+	else
+		return virt_to_phys(virt);
+}
+
+static inline void * bus_to_virt( unsigned long bus )
+{
+	if (afterburn_dma_to_phys_hook)
+		return phys_to_virt(afterburn_dma_to_phys_hook(bus));
+	else
+		return phys_to_virt(bus);
+}
+
+static inline unsigned long page_to_bus( struct page *page )
+{
+	if (afterburn_phys_to_dma_hook)
+		return afterburn_phys_to_dma_hook(page_to_phys(page),PAGE_SIZE);
+	else
+		return page_to_phys(page);
+}
+
+#define isa_virt_to_bus virt_to_bus
+#define isa_page_to_bus page_to_bus
+#define isa_bus_to_virt bus_to_virt
+
+#else
+
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
  */
+
 #define isa_virt_to_bus virt_to_phys
 #define isa_page_to_bus page_to_phys
 #define isa_bus_to_virt phys_to_virt
@@ -148,6 +186,12 @@
  *
  * Allow them on x86 for legacy drivers, though.
  */
+
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+#endif
+
 #define virt_to_bus virt_to_phys
 #define bus_to_virt phys_to_virt
 
diff -Naur linux-2.6.22.pristine/include/asm-i386/mmu_context.h linux-2.6.22-apic/include/asm-i386/mmu_context.h
--- linux-2.6.22.pristine/include/asm-i386/mmu_context.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/mmu_context.h	2007-08-03 16:34:11.000000000 +0200
@@ -7,7 +7,22 @@
 #include <asm/tlbflush.h>
 #include <asm/paravirt.h>
 #ifndef CONFIG_PARAVIRT
+
+#if defined(CONFIG_AFTERBURN)
+#include "../../../afterburn/afterburn.h"
+static inline void arch_exit_mmap(struct mm_struct *mm)
+{
+    if (afterburn_free_pgd_hook)
+	afterburn_free_pgd_hook(__pa((void*)mm->pgd));
+}
+static inline void arch_dup_mmap(struct mm_struct *oldmm,
+				 struct mm_struct *mm)
+{
+}
+
+#else
 #include <asm-generic/mm_hooks.h>
+#endif
 
 static inline void paravirt_activate_mm(struct mm_struct *prev,
 					struct mm_struct *next)
diff -Naur linux-2.6.22.pristine/include/asm-i386/page.h linux-2.6.22-apic/include/asm-i386/page.h
--- linux-2.6.22.pristine/include/asm-i386/page.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/page.h	2007-08-03 16:34:11.000000000 +0200
@@ -80,8 +80,15 @@
 }
 
 #ifndef CONFIG_PARAVIRT
+
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+#define pmd_val(x) pgd_read_annotate( (x).pmd )
+#else
 #define pmd_val(x)	native_pmd_val(x)
+#endif
 #define __pmd(x)	native_make_pmd(x)
+
+
 #endif
 
 #define HPAGE_SHIFT	21
@@ -125,13 +132,20 @@
 #define HAVE_ARCH_HUGETLB_UNMAPPED_AREA
 #endif
 
+
 #define pgprot_val(x)	((x).pgprot)
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
 #ifndef CONFIG_PARAVIRT
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#define pgd_val(x)	pgd_read_annotate( x )
+#define pte_val(x)	pte_read_annotate( x )
+#else
 #define pgd_val(x)	native_pgd_val(x)
-#define __pgd(x)	native_make_pgd(x)
 #define pte_val(x)	native_pte_val(x)
+#endif
+
+#define __pgd(x)	native_make_pgd(x)
 #define __pte(x)	native_make_pte(x)
 #endif
 
@@ -169,16 +183,25 @@
 
 #endif /* __ASSEMBLY__ */
 
-#ifdef __ASSEMBLY__
-#define __PAGE_OFFSET		CONFIG_PAGE_OFFSET
+#if defined(CONFIG_AFTERBURN_RELINK)
+# ifdef __ASSEMBLY__
+# define __PAGE_OFFSET		(CONFIG_AFTERBURN_LINK_BASE)
+# else
+# define __PAGE_OFFSET		((unsigned long)CONFIG_AFTERBURN_LINK_BASE)
+# endif
+# define MAXMEM			(CONFIG_AFTERBURN_VADDR_END-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #else
-#define __PAGE_OFFSET		((unsigned long)CONFIG_PAGE_OFFSET)
+# ifdef __ASSEMBLY__
+# define __PAGE_OFFSET		(0xC0000000)
+# else
+# define __PAGE_OFFSET		(0xC0000000UL)
+# endif
+# define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #endif
 
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
-#define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 /* __pa_symbol should be used for C visible symbols.
    This seems to be the official gcc blessed way to do such arithmetic. */
diff -Naur linux-2.6.22.pristine/include/asm-i386/percpu.h linux-2.6.22-apic/include/asm-i386/percpu.h
--- linux-2.6.22.pristine/include/asm-i386/percpu.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/percpu.h	2007-08-03 16:34:11.000000000 +0200
@@ -146,4 +146,5 @@
 #define x86_or_percpu(var,val) percpu_to_op("or", per_cpu__##var, val)
 #endif /* !__ASSEMBLY__ */
 
+
 #endif /* __ARCH_I386_PERCPU__ */
diff -Naur linux-2.6.22.pristine/include/asm-i386/pgtable-2level.h linux-2.6.22-apic/include/asm-i386/pgtable-2level.h
--- linux-2.6.22.pristine/include/asm-i386/pgtable-2level.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/pgtable-2level.h	2007-08-03 16:34:11.000000000 +0200
@@ -24,13 +24,26 @@
 {
 	*pmdp = pmd;
 }
+
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#define set_pte(ptep, pteval)		pte_set_annotate( (pte_t *)(ptep), (pteval).pte_low )
+#define set_pte_at(mm,addr,ptep,pteval) pte_set_annotate( (pte_t *)(ptep), (pteval).pte_low )
+#define set_pte_atomic(pteptr, pteval)	set_pte(pteptr,pteval)
+#define set_pmd(pmdptr, pmdval)		pmd_set_annotate( (pmd_t *)(pmdptr), * (unsigned long *) &pmdval )
+#else
+
 #ifndef CONFIG_PARAVIRT
+
 #define set_pte(pteptr, pteval)		native_set_pte(pteptr, pteval)
 #define set_pte_at(mm,addr,ptep,pteval) native_set_pte_at(mm, addr, ptep, pteval)
 #define set_pmd(pmdptr, pmdval)		native_set_pmd(pmdptr, pmdval)
 #endif
 
 #define set_pte_atomic(pteptr, pteval) set_pte(pteptr,pteval)
+
+#endif /* CONFIG_AFTERBURN_ANNOTATIONS */
+
 #define set_pte_present(mm,addr,ptep,pteval) set_pte_at(mm,addr,ptep,pteval)
 
 #define pte_clear(mm,addr,xp)	do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)
diff -Naur linux-2.6.22.pristine/include/asm-i386/pgtable-3level.h linux-2.6.22-apic/include/asm-i386/pgtable-3level.h
--- linux-2.6.22.pristine/include/asm-i386/pgtable-3level.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/pgtable-3level.h	2007-08-03 16:34:11.000000000 +0200
@@ -156,6 +156,11 @@
 #endif
 
 #define __HAVE_ARCH_PTE_SAME
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#define pte_same(a, b)		(pte_read_annotate(a) == pte_read_annotate(b))
+#define pte_none(x)		(!(pte_read_annotate(x)))
+#else
+
 static inline int pte_same(pte_t a, pte_t b)
 {
 	return a.pte_low == b.pte_low && a.pte_high == b.pte_high;
@@ -168,11 +173,20 @@
 	return !pte.pte_low && !pte.pte_high;
 }
 
+#endif
+
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+#include "../../afterburn/annotate.h"
+#define pte_pfn(x)		((unsigned long)(((pte_read_annotate(pte_val(x))) >> PAGE_SHIFT)))
+#else
+
 static inline unsigned long pte_pfn(pte_t pte)
 {
 	return pte_val(pte) >> PAGE_SHIFT;
 }
 
+#endif
+
 extern unsigned long long __supported_pte_mask;
 
 static inline pte_t pfn_pte(unsigned long page_nr, pgprot_t pgprot)
diff -Naur linux-2.6.22.pristine/include/asm-i386/pgtable.h linux-2.6.22-apic/include/asm-i386/pgtable.h
--- linux-2.6.22.pristine/include/asm-i386/pgtable.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/pgtable.h	2007-08-03 16:34:11.000000000 +0200
@@ -25,6 +25,9 @@
 #include <linux/list.h>
 #include <linux/spinlock.h>
 
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#include "../../afterburn/annotate.h"
+#endif
 struct mm_struct;
 struct vm_area_struct;
 
@@ -248,7 +251,12 @@
 # include <asm/pgtable-2level.h>
 #endif
 
-#ifndef CONFIG_PARAVIRT
+#if defined(CONFIG_AFTERBURN_ANNOTATIONS)
+#define pte_update(mm, addr, ptep)		do { } while (0)
+#define pte_update_defer(mm, addr, ptep)	do { } while (0)
+
+#elif !defined(CONFIG_PARAVIRT)
+
 /*
  * Rules for using pte_update - it must be called after any PTE update which
  * has not been done using the set_pte / clear_pte interfaces.  It is used by
@@ -349,6 +357,7 @@
 })
 
 #define __HAVE_ARCH_PTEP_GET_AND_CLEAR
+
 static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
 	pte_t pte = native_ptep_get_and_clear(ptep);
diff -Naur linux-2.6.22.pristine/include/asm-i386/processor.h linux-2.6.22-apic/include/asm-i386/processor.h
--- linux-2.6.22.pristine/include/asm-i386/processor.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/processor.h	2007-08-03 16:34:11.000000000 +0200
@@ -218,7 +218,11 @@
 /*
  * User space process size: 3GB (default).
  */
+#if defined(CONFIG_AFTERBURN)
+#define TASK_SIZE	(CONFIG_AFTERBURN_USER_VADDR_END)
+#else
 #define TASK_SIZE	(PAGE_OFFSET)
+#endif
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
@@ -581,8 +585,17 @@
 #define paravirt_enabled() 0
 #define __cpuid native_cpuid
 
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+#include "../../../afterburn/afterburn.h"
+#endif
 static inline void load_esp0(struct tss_struct *tss, struct thread_struct *thread)
 {
+#if defined(CONFIG_AFTERBURN_XEN_HOOKS)
+	{
+	    if( afterburn_sync_esp0 )
+		afterburn_sync_esp0();
+	}
+#endif
 	native_load_esp0(tss, thread);
 }
 
diff -Naur linux-2.6.22.pristine/include/asm-i386/uaccess.h linux-2.6.22-apic/include/asm-i386/uaccess.h
--- linux-2.6.22.pristine/include/asm-i386/uaccess.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/asm-i386/uaccess.h	2007-08-03 16:34:11.000000000 +0200
@@ -23,6 +23,14 @@
 
 #define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
 
+#if defined(CONFIG_AFTERBURN_HOOK_UACCESS)
+#define ON_AFTERBURN_HOOK_UACCESS(a) a
+#include "../../../afterburn/afterburn.h"
+#else
+#define ON_AFTERBURN_HOOK_UACCESS(a)
+#endif
+
+
 
 #define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFFUL)
 #define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
@@ -149,12 +157,23 @@
 ({	int __ret_gu;							\
 	unsigned long __val_gu;						\
 	__chk_user_ptr(ptr);						\
+ON_AFTERBURN_HOOK_UACCESS(						\
+	if(afterburn_get_user_hook) { 					\
+		if(unlikely(!__addr_ok(ptr)))				\
+			__ret_gu = 0;					\
+		else							\
+			__ret_gu = afterburn_get_user_hook(&__val_gu, ptr, sizeof(*(ptr)));\
+		if(likely(__ret_gu == sizeof(*(ptr)))) __ret_gu = 0;	\
+		else { __ret_gu = -EFAULT; __val_gu = 0; }		\
+	} else {							\
+)									\
 	switch(sizeof (*(ptr))) {					\
 	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
 	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
 	case 4:  __get_user_x(4,__ret_gu,__val_gu,ptr); break;		\
 	default: __get_user_x(X,__ret_gu,__val_gu,ptr); break;		\
 	}								\
+ON_AFTERBURN_HOOK_UACCESS( } )						\
 	(x) = (__typeof__(*(ptr)))__val_gu;				\
 	__ret_gu;							\
 })
@@ -298,17 +317,25 @@
 #ifdef CONFIG_X86_WP_WORKS_OK
 
 #define __put_user_size(x,ptr,size,retval,errret)			\
-do {									\
+    do {								\
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
-	switch (size) {							\
-	case 1: __put_user_asm(x,ptr,retval,"b","b","iq",errret);break;	\
-	case 2: __put_user_asm(x,ptr,retval,"w","w","ir",errret);break; \
-	case 4: __put_user_asm(x,ptr,retval,"l","","ir",errret); break;	\
-	case 8: __put_user_u64((__typeof__(*ptr))(x),ptr,retval); break;\
-	  default: __put_user_bad();					\
-	}								\
-} while (0)
+	ON_AFTERBURN_HOOK_UACCESS(					\
+	    if(afterburn_put_user_hook) {				\
+		__typeof__(*(ptr)) __pus_tmp = x; 			\
+		if(unlikely(!afterburn_put_user_hook(ptr, &__pus_tmp, size))) \
+		    retval = errret;					\
+	    } else {							\
+		)							\
+	    switch (size) {						\
+	    case 1: __put_user_asm(x,ptr,retval,"b","b","iq",errret);break; \
+	    case 2: __put_user_asm(x,ptr,retval,"w","w","ir",errret);break; \
+	    case 4: __put_user_asm(x,ptr,retval,"l","","ir",errret); break; \
+	    case 8: __put_user_u64((__typeof__(*ptr))(x),ptr,retval); break; \
+	    default: __put_user_bad();					\
+	    }								\
+	    ON_AFTERBURN_HOOK_UACCESS( } )				\
+    } while (0)
 
 #else
 
@@ -362,11 +389,19 @@
 	retval = 0;							\
 	__chk_user_ptr(ptr);						\
 	switch (size) {							\
+ON_AFTERBURN_HOOK_UACCESS(						\
+	if(afterburn_get_user_hook) {					\
+		if(unlikely(!afterburn_get_user_hook(&(x), ptr, size)))	\
+			{ (x) = 0; retval = errret; }			\
+	}								\
+	else {								\
+)									\
 	case 1: __get_user_asm(x,ptr,retval,"b","b","=q",errret);break;	\
 	case 2: __get_user_asm(x,ptr,retval,"w","w","=r",errret);break;	\
 	case 4: __get_user_asm(x,ptr,retval,"l","","=r",errret);break;	\
 	default: (x) = __get_user_bad();				\
 	}								\
+ON_AFTERBURN_HOOK_UACCESS( } )						\
 } while (0)
 
 #define __get_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
diff -Naur linux-2.6.22.pristine/include/linux/sched.h linux-2.6.22-apic/include/linux/sched.h
--- linux-2.6.22.pristine/include/linux/sched.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/include/linux/sched.h	2007-08-03 16:34:11.000000000 +0200
@@ -853,7 +853,10 @@
 #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
 	struct sched_info sched_info;
 #endif
-
+#ifdef CONFIG_AFTERBURN_THREAD_HOOKS
+	void * afterburn_handle;
+#endif
+   
 	struct list_head tasks;
 	/*
 	 * ptrace_list/ptrace_children forms the list of my children
diff -Naur linux-2.6.22.pristine/kernel/exit.c linux-2.6.22-apic/kernel/exit.c
--- linux-2.6.22.pristine/kernel/exit.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/kernel/exit.c	2007-08-03 16:34:11.000000000 +0200
@@ -859,6 +859,9 @@
 		release_task(tsk);
 }
 
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+#include "../afterburn/afterburn.h"
+#endif
 fastcall NORET_TYPE void do_exit(long code)
 {
 	struct task_struct *tsk = current;
@@ -950,7 +953,13 @@
 	exit_sem(tsk);
 	__exit_files(tsk);
 	__exit_fs(tsk);
-	exit_thread();
+	exit_thread();	
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+	{
+	    afterburn_exit_hook(tsk->afterburn_handle);
+	}
+#endif
+
 	cpuset_exit(tsk);
 	exit_keys(tsk);
 
diff -Naur linux-2.6.22.pristine/kernel/fork.c linux-2.6.22-apic/kernel/fork.c
--- linux-2.6.22.pristine/kernel/fork.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/kernel/fork.c	2007-08-03 16:34:11.000000000 +0200
@@ -1030,6 +1030,10 @@
 		if (put_user(p->pid, parent_tidptr))
 			goto bad_fork_cleanup_delays_binfmt;
 
+#if defined(CONFIG_AFTERBURN_THREAD_HOOKS)
+	p->afterburn_handle = NULL;
+#endif
+
 	INIT_LIST_HEAD(&p->children);
 	INIT_LIST_HEAD(&p->sibling);
 	p->vfork_done = NULL;
diff -Naur linux-2.6.22.pristine/kernel/module.c linux-2.6.22-apic/kernel/module.c
--- linux-2.6.22.pristine/kernel/module.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/kernel/module.c	2007-08-03 16:34:11.000000000 +0200
@@ -46,6 +46,10 @@
 #include <asm/cacheflush.h>
 #include <linux/license.h>
 
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+#include "../afterburn/afterburn.h"
+#endif
+
 extern int module_sysfs_initialized;
 
 #if 0
@@ -1782,6 +1786,15 @@
 		sechdrs[i].sh_addr = (unsigned long)dest;
 		DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);
 	}
+#if defined(CONFIG_AFTERBURN_MODULE_HOOKS)
+	{
+	    if( afterburn_rewrite_module_hook && 
+		    !afterburn_rewrite_module_hook(hdr) ) {
+	       	err = -ENOEXEC;
+    		goto cleanup;
+	    }
+	}
+#endif
 	/* Module has been moved. */
 	mod = (void *)sechdrs[modindex].sh_addr;
 
diff -Naur linux-2.6.22.pristine/Makefile linux-2.6.22-apic/Makefile
--- linux-2.6.22.pristine/Makefile	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/Makefile	2007-08-03 16:34:11.000000000 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 22
-EXTRAVERSION =
+EXTRAVERSION = -afterburn
 NAME = Holy Dancing Manatees, Batman!
 
 # *DOCUMENTATION*
@@ -195,10 +195,11 @@
 	  else if [ -x /bin/bash ]; then echo /bin/bash; \
 	  else echo sh; fi ; fi)
 
-HOSTCC       = gcc
-HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
-HOSTCXXFLAGS = -O2
+HOSTCC	     ?= ${CC}
+HOSTCXX      =  ${CC}
+HOSTCXX      =  g++
+HOSTCFLAGS   =  -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCXXFLAGS =  -O2
 
 # Decide whether to build built-in, modular, or both.
 # Normally, just do built-in.
@@ -281,7 +282,7 @@
 
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
-CC		= $(CROSS_COMPILE)gcc
+CC		?= $(CROSS_COMPILE)gcc
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
@@ -554,6 +555,7 @@
 
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-$(CONFIG_AFTERBURN) += afterburn/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -Naur linux-2.6.22.pristine/mm/mmap.c linux-2.6.22-apic/mm/mmap.c
--- linux-2.6.22.pristine/mm/mmap.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/mm/mmap.c	2007-08-03 16:34:11.000000000 +0200
@@ -1977,6 +1977,7 @@
 	arch_exit_mmap(mm);
 
 	lru_add_drain();
+	
 	flush_cache_mm(mm);
 	tlb = tlb_gather_mmu(mm, 1);
 	/* Don't update_hiwater_rss(mm) here, do_exit already did */
diff -Naur linux-2.6.22.pristine/scripts/Makefile.build linux-2.6.22-apic/scripts/Makefile.build
--- linux-2.6.22.pristine/scripts/Makefile.build	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/scripts/Makefile.build	2007-08-03 16:34:11.000000000 +0200
@@ -156,7 +156,15 @@
 quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
 
 ifndef CONFIG_MODVERSIONS
+ifndef CONFIG_AFTERBURN
 cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
+else
+params_afterburner-$(CONFIG_AFTERBURN_KERNEL_PROFILING) = -p
+params_cc_o_c-$(CONFIG_AFTERBURN_KERNEL_PROFILING) = -pg
+cmd_cc_o_c  = $(CC) $(c_flags) -c -S $(params_cc_o_c-y) -o $(@D)/.preburn_$(@F:.o=.s) $< 
+cmd_cc_o_c += && afterburner $(params_afterburner-y) $(@D)/.preburn_$(@F:.o=.s) > $(@D)/.afterburnt_$(@F:.o=.s)
+cmd_cc_o_c += && $(CC) $(filter-out -g,$(c_flags)) -c -o $@ $(@D)/.afterburnt_$(@F:.o=.s)
+endif
 
 else
 # When module versioning is enabled the following steps are executed:
@@ -232,7 +240,13 @@
 	$(call if_changed_dep,as_s_S)
 
 quiet_cmd_as_o_S = AS $(quiet_modtag)  $@
+ifndef CONFIG_AFTERBURN
 cmd_as_o_S       = $(CC) $(a_flags) -c -o $@ $<
+else
+cmd_as_o_S        = $(CC) $(a_flags) -c -E -o $(@D)/.preburn_$(@F:.o=.s) $< 
+cmd_as_o_S       += && afterburner $(@D)/.preburn_$(@F:.o=.s) > $(@D)/.afterburnt_$(@F:.o=.s)
+cmd_as_o_S       += && $(CC) $(filter-out -g,$(a_flags)) -c -o $@ $(@D)/.afterburnt_$(@F:.o=.s)
+endif
 
 $(obj)/%.o: $(src)/%.S FORCE
 	$(call if_changed_dep,as_o_S)
diff -Naur linux-2.6.22.pristine/scripts/mod/modpost.c linux-2.6.22-apic/scripts/mod/modpost.c
--- linux-2.6.22.pristine/scripts/mod/modpost.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-apic/scripts/mod/modpost.c	2007-08-03 16:34:11.000000000 +0200
@@ -14,6 +14,8 @@
 #include <ctype.h>
 #include "modpost.h"
 #include "../../include/linux/license.h"
+#include "../../afterburn/modpost.h"
+
 
 /* Are we using CONFIG_MODVERSIONS? */
 int modversions = 0;
@@ -1080,6 +1082,10 @@
 	for (s = namelist3; *s; s++)
 		if (strstr(name, *s) != NULL)
 			return 1;
+	for (s = afterburn_section_ref_ok; *s; s++)
+		if (strstr(name, *s) != NULL)
+			return 1;
+
 	if (strrcmp(name, ".init") == 0)
 		return 1;
 	return 0;
@@ -1156,6 +1162,10 @@
 	for (s = namelist3; *s; s++)
 		if (strstr(name, *s) != NULL)
 			return 1;
+	for (s = afterburn_section_ref_ok; *s; s++)
+		if (strstr(name, *s) != NULL)
+			return 1;
+
 	return 0;
 }
 
