/*****************************************************************
 * DO NOT EDIT - MACHINE-GENERATED FILE!
 * 
 * Source file : /home/stoess/devel/afterburner///l4ka-interfaces/resourcemon_idl.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 23/10/2007 14:09
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#if !defined(__resourcemon_idl_client_h__)
#define __resourcemon_idl_client_h__

#define IDL4_OMIT_FRAME_POINTER 0
#define IDL4_USE_FASTCALL 0
#define IDL4_NEED_MALLOC 0
#define IDL4_API v4
#define IDL4_ARCH ia32

#include "idl4/idl4.h"

#if defined(IDL4_HEADER_REVISION) && IDL4_HEADER_REVISION < 20060813
#error You are using outdated versions of the IDL4 header files
#endif /* defined(IDL4_HEADER_REVISION) && IDL4_HEADER_REVISION < 20060813 */

#include "l4/types.h"

#define max_cpus 16

#define max_domains 32

#define UUID_Max_IF 13

#define UUID_ILocator 0

#define UUID_IResourcemon 1

#define UUID_IConsole 2

#define UUID_IVMControl 8

#if !defined(_typedef___guid_t)
#define _typedef___guid_t
typedef int  guid_t;
#endif /* !defined(_typedef___guid_t) */

/* Interface ILocator */

#if !defined(_objdef___ILocator)
#define _objdef___ILocator
typedef CORBA_Object  ILocator;
#endif /* !defined(_objdef___ILocator) */

#define ex_ILocator_invalid_guid_format 1

#if !defined(_typedef___ILocator_invalid_guid_format)
#define _typedef___ILocator_invalid_guid_format
typedef struct ILocator_invalid_guid_format  ILocator_invalid_guid_format;
#endif /* !defined(_typedef___ILocator_invalid_guid_format) */

#define ex_ILocator_unknown_interface 2

#if !defined(_typedef___ILocator_unknown_interface)
#define _typedef___ILocator_unknown_interface
typedef struct ILocator_unknown_interface  ILocator_unknown_interface;
#endif /* !defined(_typedef___ILocator_unknown_interface) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: guid_t  guid                 2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  tid           3    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1

#if !defined(_funcdef___ILocator_query_interface)
#define _funcdef___ILocator_query_interface
static inline void  ILocator_query_interface(ILocator  _service, const guid_t  guid, L4_ThreadId_t * tid, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      guid_t  guid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  tid;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.guid = guid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((0U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *tid = _pack->_out.tid;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___ILocator_query_interface) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: guid_t  guid                 2    4    4    4 x----  -1
//   R8: L4_ThreadId_t  tid           3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         5   -1    4    4 -p---  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1

#if !defined(_funcdef___ILocator_register_interface)
#define _funcdef___ILocator_register_interface
static inline void  ILocator_register_interface(ILocator  _service, const guid_t  guid, const L4_ThreadId_t * tid, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      guid_t  guid;
      L4_ThreadId_t  tid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.guid = guid;
  _pack->_in.tid = *tid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((1U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___ILocator_register_interface) */

/* Interface IConsole */

#if !defined(_objdef___IConsole)
#define _objdef___IConsole
typedef CORBA_Object  IConsole;
#endif /* !defined(_objdef___IConsole) */

#define IConsole_max_len 128

#if !defined(_typedef___IConsole_handle_t)
#define _typedef___IConsole_handle_t
typedef unsigned int  IConsole_handle_t;
#endif /* !defined(_typedef___IConsole_handle_t) */

#if !defined(_typedef___IConsole_content_t)
#define _typedef___IConsole_content_t
typedef struct {
  char  raw[128];
  unsigned int  len;
}  IConsole_content_t;
#endif /* !defined(_typedef___IConsole_content_t) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: IConsole_content_t  content  3    4  132    4 x----  -1
//   R136: IConsole_handle_t  handle  2  136    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         5   -1    4    4 -p---  -1

#if !defined(_funcdef___IConsole_put_chars)
#define _funcdef___IConsole_put_chars
static inline void  IConsole_put_chars(IConsole  _service, const IConsole_handle_t  handle, const IConsole_content_t * content, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      IConsole_content_t  content;
      IConsole_handle_t  handle;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.handle = handle;
  _pack->_in.content = *content;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (34+((128U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IConsole_put_chars) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: IConsole_handle_t  handle    2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: IConsole_content_t  content  3    4  132    4 x----  -1

#if !defined(_funcdef___IConsole_get_chars)
#define _funcdef___IConsole_get_chars
static inline void  IConsole_get_chars(IConsole  _service, const IConsole_handle_t  handle, IConsole_content_t * content, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      IConsole_handle_t  handle;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      IConsole_content_t  content;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.handle = handle;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "mov %%ebp, 8(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((129U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *content = _pack->_out.content;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IConsole_get_chars) */

/* Interface IVMControl */

#if !defined(_objdef___IVMControl)
#define _objdef___IVMControl
typedef CORBA_Object  IVMControl;
#endif /* !defined(_objdef___IVMControl) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: L4_Word_t  millisecond_sleep 1    4    4    4 x----  -1
//   R8: L4_Word_t  num_samples       2    8    4    4 x----  -1
//   R12: L4_Word_t  target_space_id  3   12    4    4 x----  -1

#if !defined(_funcdef___IVMControl_start_working_set_scan)
#define _funcdef___IVMControl_start_working_set_scan
static inline void  IVMControl_start_working_set_scan(IVMControl  _service, const L4_Word_t  millisecond_sleep, const L4_Word_t  num_samples, const L4_Word_t  target_space_id, CORBA_Environment * _env)

{
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  millisecond_sleep;
      L4_Word_t  num_samples;
      L4_Word_t  target_space_id;
    }  _in;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.millisecond_sleep = millisecond_sleep;
  _pack->_in.num_samples = num_samples;
  _pack->_in.target_space_id = target_space_id;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "xor %%edx, %%edx                   \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (3+((512U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
    }
}
#endif /* !defined(_funcdef___IVMControl_start_working_set_scan) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: L4_Word_t  millisecond_sleep 1    4    4    4 x----  -1
//   R8: L4_Word_t  target_space_id   2    8    4    4 x----  -1

#if !defined(_funcdef___IVMControl_start_active_page_scan)
#define _funcdef___IVMControl_start_active_page_scan
static inline void  IVMControl_start_active_page_scan(IVMControl  _service, const L4_Word_t  millisecond_sleep, const L4_Word_t  target_space_id, CORBA_Environment * _env)

{
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  millisecond_sleep;
      L4_Word_t  target_space_id;
    }  _in;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.millisecond_sleep = millisecond_sleep;
  _pack->_in.target_space_id = target_space_id;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "xor %%edx, %%edx                   \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((513U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
    }
}
#endif /* !defined(_funcdef___IVMControl_start_active_page_scan) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: L4_Word_t  size              1    4    4    4 x----  -1
//   R8: L4_Word_t  target_space_id   2    8    4    4 x----  -1

#if !defined(_funcdef___IVMControl_set_memballoon)
#define _funcdef___IVMControl_set_memballoon
static inline void  IVMControl_set_memballoon(IVMControl  _service, const L4_Word_t  size, const L4_Word_t  target_space_id, CORBA_Environment * _env)

{
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  size;
      L4_Word_t  target_space_id;
    }  _in;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.size = size;
  _pack->_in.target_space_id = target_space_id;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "xor %%edx, %%edx                   \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((514U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
    }
}
#endif /* !defined(_funcdef___IVMControl_set_memballoon) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_Word_t  space_id          2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: L4_Word_t  phys_start        3    4    4    4 x----  -1
//   R8: L4_Word_t  phys_size         4    8    4    4 x----  -1

#if !defined(_funcdef___IVMControl_get_space_phys_range)
#define _funcdef___IVMControl_get_space_phys_range
static inline void  IVMControl_get_space_phys_range(IVMControl  _service, const L4_Word_t  space_id, L4_Word_t * phys_start, L4_Word_t * phys_size, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  space_id;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  phys_start;
      L4_Word_t  phys_size;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.space_id = space_id;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "mov %%ebp, 8(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((515U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *phys_start = _pack->_out.phys_start;
      *phys_size = _pack->_out.phys_size;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IVMControl_get_space_phys_range) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: L4_Word_t  space_id          2    4    4    4 x----  -1
//   R8: L4_Word_t  offset            3    8    4    4 x----  -1
//   R12: unsigned int  request_size  4   12    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1
//   S0: char  data                   5    0  var    1 x----   0

#if !defined(_funcdef___IVMControl_get_space_block)
#define _funcdef___IVMControl_get_space_block
static inline void  IVMControl_get_space_block(IVMControl  _service, const L4_Word_t  space_id, const L4_Word_t  offset, const unsigned int  request_size, char ** data, unsigned int * size, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  space_id;
      L4_Word_t  offset;
      unsigned int  request_size;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      idl4_stringitem  data;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  L4_Word_t  _rcv_buf0 = (L4_Word_t)*data;
  L4_LoadBR(0, 1);
  L4_LoadBR(1, *size * sizeof(char) << 10);
  L4_LoadBR(2, _rcv_buf0);
  _pack->_in.space_id = space_id;
  _pack->_in.offset = offset;
  _pack->_in.request_size = request_size;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (3+((516U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  L4_LoadBR(0, 0);

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *size = _pack->_out.data.len >> 10;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IVMControl_get_space_block) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: L4_Word_t  millisecond_sleep 1    4    4    4 x----  -1
//   R8: L4_Word_t  num_samples       2    8    4    4 x----  -1

#if !defined(_funcdef___IVMControl_start_perfmon_scan)
#define _funcdef___IVMControl_start_perfmon_scan
static inline void  IVMControl_start_perfmon_scan(IVMControl  _service, const L4_Word_t  millisecond_sleep, const L4_Word_t  num_samples, CORBA_Environment * _env)

{
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  millisecond_sleep;
      L4_Word_t  num_samples;
    }  _in;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.millisecond_sleep = millisecond_sleep;
  _pack->_in.num_samples = num_samples;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "xor %%edx, %%edx                   \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((517U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
    }
}
#endif /* !defined(_funcdef___IVMControl_start_perfmon_scan) */

/* Interface IResourcemon */

#if !defined(_objdef___IResourcemon)
#define _objdef___IResourcemon
typedef CORBA_Object  IResourcemon;
#endif /* !defined(_objdef___IResourcemon) */

#define IResourcemon_version 1

#define IResourcemon_max_cpus 16

#define IResourcemon_max_vcpus 32

#define IResourcemon_max_modules 2

#define IResourcemon_max_devices 16

#if !defined(_typedef___IResourcemon_shared_cpu)
#define _typedef___IResourcemon_shared_cpu
struct IResourcemon_shared_cpu {
  L4_Word_t  time_balloon;
  L4_ThreadId_t  virq_tid;
};
#endif /* !defined(_typedef___IResourcemon_shared_cpu) */

#if !defined(_typedef___IResourcemon_shared_cpu_t)
#define _typedef___IResourcemon_shared_cpu_t
typedef struct IResourcemon_shared_cpu  IResourcemon_shared_cpu_t;
#endif /* !defined(_typedef___IResourcemon_shared_cpu_t) */

#if !defined(_typedef___IResourcemon_shared_vcpu)
#define _typedef___IResourcemon_shared_vcpu
struct IResourcemon_shared_vcpu {
  L4_ThreadId_t  monitor_tid;
  L4_Word_t  pcpu;
};
#endif /* !defined(_typedef___IResourcemon_shared_vcpu) */

#if !defined(_typedef___IResourcemon_shared_vcpu_t)
#define _typedef___IResourcemon_shared_vcpu_t
typedef struct IResourcemon_shared_vcpu  IResourcemon_shared_vcpu_t;
#endif /* !defined(_typedef___IResourcemon_shared_vcpu_t) */

#if !defined(_typedef___IResourcemon_shared_module)
#define _typedef___IResourcemon_shared_module
struct IResourcemon_shared_module {
  L4_Word_t  vm_offset;
  L4_Word_t  size;
  char  cmdline[512];
};
#endif /* !defined(_typedef___IResourcemon_shared_module) */

#if !defined(_typedef___IResourcemon_shared_module_t)
#define _typedef___IResourcemon_shared_module_t
typedef struct IResourcemon_shared_module  IResourcemon_shared_module_t;
#endif /* !defined(_typedef___IResourcemon_shared_module_t) */

#if !defined(_typedef___IResourcemon_shared_device)
#define _typedef___IResourcemon_shared_device
struct IResourcemon_shared_device {
  L4_Word_t  low;
  L4_Word_t  high;
  L4_Word_t  type;
};
#endif /* !defined(_typedef___IResourcemon_shared_device) */

#if !defined(_typedef___IResourcemon_shared_device_t)
#define _typedef___IResourcemon_shared_device_t
typedef struct IResourcemon_shared_device  IResourcemon_shared_device_t;
#endif /* !defined(_typedef___IResourcemon_shared_device_t) */

#if !defined(_typedef___IResourcemon_shared)
#define _typedef___IResourcemon_shared
struct IResourcemon_shared {
  L4_Word_t  version;
  L4_Word_t  cpu_cnt;
  L4_Word_t  prio;
  L4_Word_t  ramdisk_start;
  L4_Word_t  ramdisk_size;
  L4_Word_t  thread_space_start;
  L4_Word_t  thread_space_len;
  L4_Fpage_t  utcb_fpage;
  L4_Fpage_t  kip_fpage;
  L4_Word_t  link_vaddr;
  L4_Word_t  entry_ip;
  L4_Word_t  entry_sp;
  L4_Word_t  phys_offset;
  L4_Word_t  phys_size;
  L4_Word_t  phys_end;
  L4_Word_t  wedge_virt_offset;
  L4_Word_t  wedge_phys_offset;
  L4_Word_t  wedge_phys_size;
  L4_Word_t  wedge_virt_size;
  L4_ThreadId_t  resourcemon_tid;
  L4_ThreadId_t  locator_tid;
  L4_ThreadId_t  thread_server_tid;
  L4_Word_t  mem_balloon;
  char  cmdline[256];
  L4_Word_t  module_count;
  IResourcemon_shared_module_t  modules[2];
  IResourcemon_shared_device_t  devices[16];
  L4_Word_t  vcpu_count;
  L4_Word_t  pcpu_count;
  L4_Word_t  vcpus_to_l4cpu[16];
  IResourcemon_shared_cpu_t  cpu[16];
  IResourcemon_shared_vcpu_t  vcpu[32];
  L4_Word_t  virq_pending[8];
};
#endif /* !defined(_typedef___IResourcemon_shared) */

#if !defined(_typedef___IResourcemon_shared_t)
#define _typedef___IResourcemon_shared_t
typedef struct IResourcemon_shared  IResourcemon_shared_t;
#endif /* !defined(_typedef___IResourcemon_shared_t) */

#if !defined(_typedef___IResourcemon_startup_config)
#define _typedef___IResourcemon_startup_config
struct IResourcemon_startup_config {
  L4_Word_t  version;
  L4_Word_t  start_ip;
  L4_Word_t  start_sp;
};
#endif /* !defined(_typedef___IResourcemon_startup_config) */

#if !defined(_typedef___IResourcemon_startup_config_t)
#define _typedef___IResourcemon_startup_config_t
typedef struct IResourcemon_startup_config  IResourcemon_startup_config_t;
#endif /* !defined(_typedef___IResourcemon_startup_config_t) */

#define ex_IResourcemon_unknown_client 1

#if !defined(_typedef___IResourcemon_unknown_client)
#define _typedef___IResourcemon_unknown_client
typedef struct IResourcemon_unknown_client  IResourcemon_unknown_client;
#endif /* !defined(_typedef___IResourcemon_unknown_client) */

#define ex_IResourcemon_invalid_mem_region 2

#if !defined(_typedef___IResourcemon_invalid_mem_region)
#define _typedef___IResourcemon_invalid_mem_region
typedef struct IResourcemon_invalid_mem_region  IResourcemon_invalid_mem_region;
#endif /* !defined(_typedef___IResourcemon_invalid_mem_region) */

#define ex_IResourcemon_no_permission 3

#if !defined(_typedef___IResourcemon_no_permission)
#define _typedef___IResourcemon_no_permission
typedef struct IResourcemon_no_permission  IResourcemon_no_permission;
#endif /* !defined(_typedef___IResourcemon_no_permission) */

#define ex_IResourcemon_device_not_mapped 4

#if !defined(_typedef___IResourcemon_device_not_mapped)
#define _typedef___IResourcemon_device_not_mapped
typedef struct IResourcemon_device_not_mapped  IResourcemon_device_not_mapped;
#endif /* !defined(_typedef___IResourcemon_device_not_mapped) */

#define ex_IResourcemon_ErrOk 5

#if !defined(_typedef___IResourcemon_ErrOk)
#define _typedef___IResourcemon_ErrOk
typedef struct IResourcemon_ErrOk  IResourcemon_ErrOk;
#endif /* !defined(_typedef___IResourcemon_ErrOk) */

#define ex_IResourcemon_ErrNoPrivilege 6

#if !defined(_typedef___IResourcemon_ErrNoPrivilege)
#define _typedef___IResourcemon_ErrNoPrivilege
typedef struct IResourcemon_ErrNoPrivilege  IResourcemon_ErrNoPrivilege;
#endif /* !defined(_typedef___IResourcemon_ErrNoPrivilege) */

#define ex_IResourcemon_ErrInvalidThread 7

#if !defined(_typedef___IResourcemon_ErrInvalidThread)
#define _typedef___IResourcemon_ErrInvalidThread
typedef struct IResourcemon_ErrInvalidThread  IResourcemon_ErrInvalidThread;
#endif /* !defined(_typedef___IResourcemon_ErrInvalidThread) */

#define ex_IResourcemon_ErrInvalidSpace 8

#if !defined(_typedef___IResourcemon_ErrInvalidSpace)
#define _typedef___IResourcemon_ErrInvalidSpace
typedef struct IResourcemon_ErrInvalidSpace  IResourcemon_ErrInvalidSpace;
#endif /* !defined(_typedef___IResourcemon_ErrInvalidSpace) */

#define ex_IResourcemon_ErrInvalidScheduler 9

#if !defined(_typedef___IResourcemon_ErrInvalidScheduler)
#define _typedef___IResourcemon_ErrInvalidScheduler
typedef struct IResourcemon_ErrInvalidScheduler  IResourcemon_ErrInvalidScheduler;
#endif /* !defined(_typedef___IResourcemon_ErrInvalidScheduler) */

#define ex_IResourcemon_ErrInvalidParam 10

#if !defined(_typedef___IResourcemon_ErrInvalidParam)
#define _typedef___IResourcemon_ErrInvalidParam
typedef struct IResourcemon_ErrInvalidParam  IResourcemon_ErrInvalidParam;
#endif /* !defined(_typedef___IResourcemon_ErrInvalidParam) */

#define ex_IResourcemon_ErrUtcbArea 11

#if !defined(_typedef___IResourcemon_ErrUtcbArea)
#define _typedef___IResourcemon_ErrUtcbArea
typedef struct IResourcemon_ErrUtcbArea  IResourcemon_ErrUtcbArea;
#endif /* !defined(_typedef___IResourcemon_ErrUtcbArea) */

#define ex_IResourcemon_ErrKipArea 12

#if !defined(_typedef___IResourcemon_ErrKipArea)
#define _typedef___IResourcemon_ErrKipArea
typedef struct IResourcemon_ErrKipArea  IResourcemon_ErrKipArea;
#endif /* !defined(_typedef___IResourcemon_ErrKipArea) */

#define ex_IResourcemon_ErrNoMem 13

#if !defined(_typedef___IResourcemon_ErrNoMem)
#define _typedef___IResourcemon_ErrNoMem
typedef struct IResourcemon_ErrNoMem  IResourcemon_ErrNoMem;
#endif /* !defined(_typedef___IResourcemon_ErrNoMem) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: L4_Word_t  addr              2    4    4    4 x----  -1
//   R8: L4_Word_t  ip                3    8    4    4 x----  -1
//   X-: L4_Word_t  privileges        4   -1    4    4 x-1--  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1
//   F0: idl4_fpage_t  p              5    0    1    1 x----  -1

#if !defined(_funcdef___IResourcemon_pagefault)
#define _funcdef___IResourcemon_pagefault
static inline void  IResourcemon_pagefault(IResourcemon  _service, const L4_Word_t  addr, const L4_Word_t  ip, const L4_Word_t  privileges, idl4_fpage_t * p, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  addr;
      L4_Word_t  ip;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      idl4_mapitem  p;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  L4_LoadBR(0, 0 | _env->_rcv_window.raw);
  _pack->_in.addr = addr;
  _pack->_in.ip = ip;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((65504U+(privileges & 7)) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  L4_LoadBR(0, 0);

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *p = _pack->_out.p;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_pagefault) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: L4_Word_t  addr              2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         4   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_register_pdirptr)
#define _funcdef___IResourcemon_register_pdirptr
static inline void  IResourcemon_register_pdirptr(IResourcemon  _service, const L4_Word_t  addr, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  addr;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.addr = addr;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((65U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_register_pdirptr) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         1   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_client_init_complete)
#define _funcdef___IResourcemon_client_init_complete
static inline void  IResourcemon_client_init_complete(IResourcemon  _service, CORBA_Environment * _env)

{
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
    }  _in;
  } * _pack = (union _buf*)MyUTCB();

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "xor %%edx, %%edx                   \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (0+((66U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
    }
}
#endif /* !defined(_funcdef___IResourcemon_client_init_complete) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_Word_t  req_fp            2    4    4    4 x----  -1
//   R8: L4_Word_t  attr              3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1
//   F0: idl4_fpage_t  fp             4    0    1    1 x----  -1

#if !defined(_funcdef___IResourcemon_request_pages)
#define _funcdef___IResourcemon_request_pages
static inline void  IResourcemon_request_pages(IResourcemon  _service, const L4_Word_t  req_fp, const L4_Word_t  attr, idl4_fpage_t * fp, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  req_fp;
      L4_Word_t  attr;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      idl4_mapitem  fp;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  L4_LoadBR(0, 0 | _env->_rcv_window.raw);
  _pack->_in.req_fp = req_fp;
  _pack->_in.attr = attr;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((65440U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  L4_LoadBR(0, 0);

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *fp = _pack->_out.fp;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_request_pages) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_Word_t  req_fp            2    4    4    4 x----  -1
//   R8: L4_Word_t  attr              3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1
//   F0: idl4_fpage_t  fp             4    0    1    1 x----  -1

#if !defined(_funcdef___IResourcemon_request_device)
#define _funcdef___IResourcemon_request_device
static inline void  IResourcemon_request_device(IResourcemon  _service, const L4_Word_t  req_fp, const L4_Word_t  attr, idl4_fpage_t * fp, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  req_fp;
      L4_Word_t  attr;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      idl4_mapitem  fp;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  L4_LoadBR(0, 0 | _env->_rcv_window.raw);
  _pack->_in.req_fp = req_fp;
  _pack->_in.attr = attr;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((68U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  L4_LoadBR(0, 0);

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *fp = _pack->_out.fp;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_request_device) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_Word_t  req_fp            2    4    4    4 x----  -1
//   R8: L4_Word_t  attr              3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: L4_Word_t  old_attr          4    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_unmap_device)
#define _funcdef___IResourcemon_unmap_device
static inline void  IResourcemon_unmap_device(IResourcemon  _service, const L4_Word_t  req_fp, const L4_Word_t  attr, L4_Word_t * old_attr, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  req_fp;
      L4_Word_t  attr;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  old_attr;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.req_fp = req_fp;
  _pack->_in.attr = attr;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((69U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *old_attr = _pack->_out.old_attr;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_unmap_device) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  client_tid    2    4    4    4 x----  -1
//   R8: L4_Word_t  req_fp            3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1
//   F0: idl4_fpage_t  fp             4    0    1    1 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1
// 
// Channel 3:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         8   -1    4    4 -p---  -1
// 
// Channel 4:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         9   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_request_client_pages)
#define _funcdef___IResourcemon_request_client_pages
static inline void  IResourcemon_request_client_pages(IResourcemon  _service, const L4_ThreadId_t * client_tid, const L4_Word_t  req_fp, idl4_fpage_t * fp, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  client_tid;
      L4_Word_t  req_fp;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      idl4_mapitem  fp;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
    struct {
      idl4_word_t  _msgtag;
    }  _exc1;
    struct {
      idl4_word_t  _msgtag;
    }  _exc2;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  L4_LoadBR(0, 0 | _env->_rcv_window.raw);
  _pack->_in.client_tid = *client_tid;
  _pack->_in.req_fp = req_fp;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((70U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  L4_LoadBR(0, 0);

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *fp = _pack->_out.fp;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_request_client_pages) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         9    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  dest          2    4    4    4 x----  -1
//   R8: L4_ThreadId_t  space         3    8    4    4 x----  -1
//   R12: L4_ThreadId_t  sched        4   12    4    4 x----  -1
//   R16: L4_ThreadId_t  pager        5   16    4    4 x----  -1
//   R20: L4_Word_t  utcb_location    6   20    4    4 x----  -1
//   R24: L4_Word_t  prio             7   24    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         A    0    4    4 -p---  -1
//   R4: int  __retval                8    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         B   -1    4    4 -p---  -1
// 
// Channel 3:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         C   -1    4    4 -p---  -1
// 
// Channel 4:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         D   -1    4    4 -p---  -1
// 
// Channel 5:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         E   -1    4    4 -p---  -1
// 
// Channel 6:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         F   -1    4    4 -p---  -1
// 
// Channel 7:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         G   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_ThreadControl)
#define _funcdef___IResourcemon_ThreadControl
static inline int  IResourcemon_ThreadControl(IResourcemon  _service, const L4_ThreadId_t * dest, const L4_ThreadId_t * space, const L4_ThreadId_t * sched, const L4_ThreadId_t * pager, const L4_Word_t  utcb_location, const L4_Word_t  prio, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  dest;
      L4_ThreadId_t  space;
      L4_ThreadId_t  sched;
      L4_ThreadId_t  pager;
      L4_Word_t  utcb_location;
      L4_Word_t  prio;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      int  __retval;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
    struct {
      idl4_word_t  _msgtag;
    }  _exc1;
    struct {
      idl4_word_t  _msgtag;
    }  _exc2;
    struct {
      idl4_word_t  _msgtag;
    }  _exc3;
    struct {
      idl4_word_t  _msgtag;
    }  _exc4;
    struct {
      idl4_word_t  _msgtag;
    }  _exc5;
  } * _pack = (union _buf*)MyUTCB();
  int  __retval;

  /* marshal */
  
  _pack->_in.dest = *dest;
  _pack->_in.space = *space;
  _pack->_in.sched = *sched;
  _pack->_in.pager = *pager;
  _pack->_in.utcb_location = utcb_location;
  _pack->_in.prio = prio;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (6+((71U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }

  /* return normally */
  
  __retval = _pack->_out.__retval;
  return __retval;
}
#endif /* !defined(_funcdef___IResourcemon_ThreadControl) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         8    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  space         2    4    4    4 x----  -1
//   R8: L4_Word_t  control           3    8    4    4 x----  -1
//   R12: L4_Word_t  kip              4   12    4    4 x----  -1
//   R16: L4_Word_t  utcb             5   16    4    4 x----  -1
//   R20: L4_ThreadId_t  redir        6   20    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         9    0    4    4 -p---  -1
//   R4: int  __retval                7    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         A   -1    4    4 -p---  -1
// 
// Channel 3:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         B   -1    4    4 -p---  -1
// 
// Channel 4:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         C   -1    4    4 -p---  -1
// 
// Channel 5:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         D   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_SpaceControl)
#define _funcdef___IResourcemon_SpaceControl
static inline int  IResourcemon_SpaceControl(IResourcemon  _service, const L4_ThreadId_t * space, const L4_Word_t  control, const L4_Word_t  kip, const L4_Word_t  utcb, const L4_ThreadId_t * redir, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  space;
      L4_Word_t  control;
      L4_Word_t  kip;
      L4_Word_t  utcb;
      L4_ThreadId_t  redir;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      int  __retval;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
    struct {
      idl4_word_t  _msgtag;
    }  _exc1;
    struct {
      idl4_word_t  _msgtag;
    }  _exc2;
    struct {
      idl4_word_t  _msgtag;
    }  _exc3;
  } * _pack = (union _buf*)MyUTCB();
  int  __retval;

  /* marshal */
  
  _pack->_in.space = *space;
  _pack->_in.control = control;
  _pack->_in.kip = kip;
  _pack->_in.utcb = utcb;
  _pack->_in.redir = *redir;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (5+((72U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }

  /* return normally */
  
  __retval = _pack->_out.__retval;
  return __retval;
}
#endif /* !defined(_funcdef___IResourcemon_SpaceControl) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  irq_tid       2    4    4    4 x----  -1
//   R8: L4_ThreadId_t  handler_tid   3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: int  __retval                4    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1
// 
// Channel 3:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         8   -1    4    4 -p---  -1
// 
// Channel 4:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         9   -1    4    4 -p---  -1
// 
// Channel 5:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         A   -1    4    4 -p---  -1
// 
// Channel 6:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         B   -1    4    4 -p---  -1
// 
// Channel 7:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         C   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_AssociateInterrupt)
#define _funcdef___IResourcemon_AssociateInterrupt
static inline int  IResourcemon_AssociateInterrupt(IResourcemon  _service, const L4_ThreadId_t * irq_tid, const L4_ThreadId_t * handler_tid, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  irq_tid;
      L4_ThreadId_t  handler_tid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      int  __retval;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
    struct {
      idl4_word_t  _msgtag;
    }  _exc1;
    struct {
      idl4_word_t  _msgtag;
    }  _exc2;
    struct {
      idl4_word_t  _msgtag;
    }  _exc3;
    struct {
      idl4_word_t  _msgtag;
    }  _exc4;
    struct {
      idl4_word_t  _msgtag;
    }  _exc5;
  } * _pack = (union _buf*)MyUTCB();
  int  __retval;

  /* marshal */
  
  _pack->_in.irq_tid = *irq_tid;
  _pack->_in.handler_tid = *handler_tid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((73U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }

  /* return normally */
  
  __retval = _pack->_out.__retval;
  return __retval;
}
#endif /* !defined(_funcdef___IResourcemon_AssociateInterrupt) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  irq_tid       2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: int  __retval                3    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1
// 
// Channel 3:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1
// 
// Channel 4:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         8   -1    4    4 -p---  -1
// 
// Channel 5:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         9   -1    4    4 -p---  -1
// 
// Channel 6:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         A   -1    4    4 -p---  -1
// 
// Channel 7:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         B   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_DeassociateInterrupt)
#define _funcdef___IResourcemon_DeassociateInterrupt
static inline int  IResourcemon_DeassociateInterrupt(IResourcemon  _service, const L4_ThreadId_t * irq_tid, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  irq_tid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      int  __retval;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
    struct {
      idl4_word_t  _msgtag;
    }  _exc1;
    struct {
      idl4_word_t  _msgtag;
    }  _exc2;
    struct {
      idl4_word_t  _msgtag;
    }  _exc3;
    struct {
      idl4_word_t  _msgtag;
    }  _exc4;
    struct {
      idl4_word_t  _msgtag;
    }  _exc5;
  } * _pack = (union _buf*)MyUTCB();
  int  __retval;

  /* marshal */
  
  _pack->_in.irq_tid = *irq_tid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((74U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }

  /* return normally */
  
  __retval = _pack->_out.__retval;
  return __retval;
}
#endif /* !defined(_funcdef___IResourcemon_DeassociateInterrupt) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  client_tid    2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: L4_Word_t  phys_start        3    4    4    4 x----  -1
//   R8: L4_Word_t  phys_size         4    8    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_get_client_phys_range)
#define _funcdef___IResourcemon_get_client_phys_range
static inline void  IResourcemon_get_client_phys_range(IResourcemon  _service, const L4_ThreadId_t * client_tid, L4_Word_t * phys_start, L4_Word_t * phys_size, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  client_tid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  phys_start;
      L4_Word_t  phys_size;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.client_tid = *client_tid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "mov %%ebp, 8(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((75U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *phys_start = _pack->_out.phys_start;
      *phys_size = _pack->_out.phys_size;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_get_client_phys_range) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_Word_t  space_id          2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         6    0    4    4 -p---  -1
//   R4: L4_Word_t  phys_start        3    4    4    4 x----  -1
//   R8: L4_Word_t  phys_size         4    8    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         7   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_get_space_phys_range)
#define _funcdef___IResourcemon_get_space_phys_range
static inline void  IResourcemon_get_space_phys_range(IResourcemon  _service, const L4_Word_t  space_id, L4_Word_t * phys_start, L4_Word_t * phys_size, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  space_id;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  phys_start;
      L4_Word_t  phys_size;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.space_id = space_id;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "mov %%ebp, 8(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((76U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *phys_start = _pack->_out.phys_start;
      *phys_size = _pack->_out.phys_size;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_get_space_phys_range) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: L4_Word_t  new_offset        2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         4   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_set_virtual_offset)
#define _funcdef___IResourcemon_set_virtual_offset
static inline void  IResourcemon_set_virtual_offset(IResourcemon  _service, const L4_Word_t  new_offset, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  new_offset;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.new_offset = new_offset;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((77U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_set_virtual_offset) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  tid           2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_Word_t  space_id          3    4    4    4 x----  -1

#if !defined(_funcdef___IResourcemon_tid_to_space_id)
#define _funcdef___IResourcemon_tid_to_space_id
static inline void  IResourcemon_tid_to_space_id(IResourcemon  _service, const L4_ThreadId_t * tid, L4_Word_t * space_id, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  tid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_Word_t  space_id;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.tid = *tid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((78U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *space_id = _pack->_out.space_id;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_tid_to_space_id) */

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         3   -1    4    4 -p---  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         4   -1    4    4 -p---  -1
//   F0: idl4_fpage_t  fp             2    0    1    1 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         5   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_request_performance_counter_pages)
#define _funcdef___IResourcemon_request_performance_counter_pages
static inline void  IResourcemon_request_performance_counter_pages(IResourcemon  _service, idl4_fpage_t * fp, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      idl4_mapitem  fp;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  L4_LoadBR(0, 0 | _env->_rcv_window.raw);

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (0+((79U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  L4_LoadBR(0, 0);

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *fp = _pack->_out.fp;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_request_performance_counter_pages) */

// Inherited from ILocator

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: guid_t  guid                 2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: L4_ThreadId_t  tid           3    4    4    4 x----  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_query_interface)
#define _funcdef___IResourcemon_query_interface
static inline void  IResourcemon_query_interface(IResourcemon  _service, const guid_t  guid, L4_ThreadId_t * tid, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      guid_t  guid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      L4_ThreadId_t  tid;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.guid = guid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((0U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *tid = _pack->_out.tid;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_query_interface) */

// Inherited from ILocator

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: guid_t  guid                 2    4    4    4 x----  -1
//   R8: L4_ThreadId_t  tid           3    8    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         5   -1    4    4 -p---  -1
// 
// Channel 2:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         6   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_register_interface)
#define _funcdef___IResourcemon_register_interface
static inline void  IResourcemon_register_interface(IResourcemon  _service, const guid_t  guid, const L4_ThreadId_t * tid, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      guid_t  guid;
      L4_ThreadId_t  tid;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
    }  _out;
    struct {
      idl4_word_t  _msgtag;
    }  _exc0;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.guid = guid;
  _pack->_in.tid = *tid;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (2+((1U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_register_interface) */

// Inherited from IConsole

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: IConsole_content_t  content  3    4  132    4 x----  -1
//   R136: IConsole_handle_t  handle  2  136    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         5   -1    4    4 -p---  -1

#if !defined(_funcdef___IResourcemon_put_chars)
#define _funcdef___IResourcemon_put_chars
static inline void  IResourcemon_put_chars(IResourcemon  _service, const IConsole_handle_t  handle, const IConsole_content_t * content, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      IConsole_content_t  content;
      IConsole_handle_t  handle;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.handle = handle;
  _pack->_in.content = *content;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (34+((128U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_put_chars) */

// Inherited from IConsole

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         4    0    4    4 -p---  -1
//   R4: IConsole_handle_t  handle    2    4    4    4 x----  -1
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         5    0    4    4 -p---  -1
//   R4: IConsole_content_t  content  3    4  132    4 x----  -1

#if !defined(_funcdef___IResourcemon_get_chars)
#define _funcdef___IResourcemon_get_chars
static inline void  IResourcemon_get_chars(IResourcemon  _service, const IConsole_handle_t  handle, IConsole_content_t * content, CORBA_Environment * _env)

{
  idl4_word_t  _exception;
  idl4_word_t  _result;
  idl4_word_t  _dummy;
  union _buf {
    struct {
      idl4_word_t  _msgtag;
      IConsole_handle_t  handle;
    }  _in;
    struct {
      idl4_word_t  _msgtag;
      IConsole_content_t  content;
    }  _out;
  } * _pack = (union _buf*)MyUTCB();

  /* marshal */
  
  _pack->_in.handle = handle;

  /* invoke IPC */
  
  __asm__ __volatile__(
    "push %%ebp                         \n\t"
    "movl %%eax, %%edx                  \n\t"
    "call __L4_Ipc                      \n\t"
    "mov %%ebx, 4(%%edi)                \n\t"
    "mov %%ebp, 8(%%edi)                \n\t"
    "pop %%ebp                          \n\t"
    : "=S" (_result), "=c" (_dummy), "=a" (_dummy)
    : "S" (1+((129U) << 16)), "D" (_pack), "a" (_service), "c" ((_env == 0) ? 0 : _env->_timeout)
    : "ebx", "edx", "memory", "cc"
  );

  _exception = _result >> 16;

  if (IDL4_EXPECT_TRUE(((_result & 0xFFFF8000U) == 0) && !_exception))
    {
      /* unmarshal */
      
      *content = _pack->_out.content;
    }

  if (_env != 0)
    {
      if ((_result & 0x8000) != 0)
        *(unsigned*)_env = CORBA_SYSTEM_EXCEPTION+(ErrorCode() << 8);
        else *(unsigned*)_env = _exception;
    }
}
#endif /* !defined(_funcdef___IResourcemon_get_chars) */

#endif /* !defined(__resourcemon_idl_client_h__) */
